<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Rudiments: codetree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Rudiments
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcodetree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">codetree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7f2c7af6c092cabdbfb513fc10f3f9b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodetree.html#a7f2c7af6c092cabdbfb513fc10f3f9b4">codetree</a> ()</td></tr>
<tr class="separator:a7f2c7af6c092cabdbfb513fc10f3f9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c772b1a8603ec6d6cae0e6781123459"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodetree.html#a7c772b1a8603ec6d6cae0e6781123459">~codetree</a> ()</td></tr>
<tr class="separator:a7c772b1a8603ec6d6cae0e6781123459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74666bc86ad0906654dd32c11aed7ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodetree.html#ad74666bc86ad0906654dd32c11aed7ad">parse</a> (const char *input, const char *grammar, const char *startsymbol, <a class="el" href="classxmldomnode.html">xmldomnode</a> *output, const char **codeposition)</td></tr>
<tr class="separator:ad74666bc86ad0906654dd32c11aed7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb3a793828ca95aca4ef3e7557d8d95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodetree.html#afcb3a793828ca95aca4ef3e7557d8d95">parse</a> (const char *input, <a class="el" href="classcodetreegrammar.html">codetreegrammar</a> *grammar, const char *startsymbol, <a class="el" href="classxmldomnode.html">xmldomnode</a> *output, const char **codeposition)</td></tr>
<tr class="separator:afcb3a793828ca95aca4ef3e7557d8d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eb083aaf46b6af532c7fa772b13a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodetree.html#a81eb083aaf46b6af532c7fa772b13a63">write</a> (<a class="el" href="classxmldomnode.html">xmldomnode</a> *input, const char *grammar, <a class="el" href="classstringbuffer.html">stringbuffer</a> *output)</td></tr>
<tr class="separator:a81eb083aaf46b6af532c7fa772b13a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8875f36c1b319f2eacd860b214b4c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodetree.html#a4b8875f36c1b319f2eacd860b214b4c2">write</a> (<a class="el" href="classxmldomnode.html">xmldomnode</a> *input, <a class="el" href="classcodetreegrammar.html">codetreegrammar</a> *grammar, <a class="el" href="classstringbuffer.html">stringbuffer</a> *output)</td></tr>
<tr class="separator:a4b8875f36c1b319f2eacd860b214b4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7002d26f36e0b3fa462a3a5ebad4c43f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcodetree.html#a7002d26f36e0b3fa462a3a5ebad4c43f">setDebugLevel</a> (uint8_t debuglevel)</td></tr>
<tr class="separator:a7002d26f36e0b3fa462a3a5ebad4c43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The codetree class implements a generic parser that can parse source code (or similarly structured input) and create an XML tree representing the code. The class can also take that XML tree and write it back out as code.</p>
<p>A grammar must be specified to parse the input and write it back out. This grammar must be in a specific XML format, based on the EBNF format with a few extensions.</p>
<p>The top-level tag is &lt;grammar&gt;. Inside the grammar tag are sets of &lt;definition&gt; tags, each defining a nonterminal.</p>
<p>Each &lt;definition&gt; tag must contain sets of &lt;terminal&gt;, &lt;letter&gt;, &lt;lowercaseletter&gt;, &lt;uppercaseletter&gt;, &lt;digit&gt;, &lt;set&gt;, &lt;nonterminal&gt;, &lt;alternation&gt;, &lt;repetition&gt;, &lt;concatenation&gt;, &lt;option&gt;,  and &lt;break&gt; tags.</p>
<p>The &lt;alternation&gt;, &lt;repetition&gt;, &lt;concatenation&gt;, &lt;option&gt; and  tags must contain combinations of other tags.</p>
<p>The &lt;grammar&gt; tag may contain a single attribute:</p>
<p>indent - Optional. The string to use when indenting code as it's being written back out. The string will be repeated once for each level of indention. If omitted, tabs will be used. Setting the attribute to "&amp;#9;" will also cause tabs to be used. Otherwise whatever string is supplied will be repeated for each level of indentation. To use 4 spaces, for example, set it to "    ". To kill all indentation, set it to an empty string: "".</p>
<p>The &lt;definition&gt; tag defines a nonterminal and has the following attributes:</p>
<p>name - Required. The name of the nonterminal. This will also be the tag name used to represent the nonterminal in the XML representation of the code.</p>
<p>start - Optional. A string to be printed before the nonterminal when writing it back out.</p>
<p>If a start attribute begins with a &amp;#8; (backspace) then one level of indentation will be removed. If the previous character in the output was a line feed then it will also be removed.</p>
<p>If a start attribute contains a &amp;#10; (newline) then a new line and appropriate indentation will be inserted at that point.</p>
<p>end - Optional. A string to be printed after the nonterminal when writing it back out.</p>
<p>If an end attribute begins with a &amp;#8; (backspace) then one level of indentation will be removed. If the previous character in the output was a line feed then it will also be removed.</p>
<p>If an end attribute contains a &amp;#10; (newline) then a new line and appropriate indentation will be inserted at that point.</p>
<p>type - Optional. If supplied, it indicates that a tag representing the nonterminal should be included in the XML representation of the code and that special formatting should be used when writing that XML back out as code. There are 5 possible values: inline, literal, line, block, and none.</p>
<p>If the type attribute is omitted, then "inline" is assumed.</p>
<p>When written back out, an "inline" nonterminal is simply printed inline without any additional indentation or new lines. In the XML representing the code, the tag representing an inline may contain tags for other nonterminals. A good example of an inline in C++ (or any programming language) is an arithmetic expression which may contain many terms and operators.</p>
<p>When written back out, "literal" nonterminals are also printed inline, however in the XML representing the code, the tag representing a literal does not contain any additional tags but rather has a "value" attribute composed of the concatenation of all terminals that were ultimately encountered while parsing the section of the code described by the nonterminal. Good examples of literals in C++ (or any programming language) are integers, floating point numbers and strings.</p>
<p>When written back out, a new line is appended to "line" nonterminals. In the XML representing the code, the tag representing a line may contain tags for other nonterminals. A good example of a line in C++ is a statement, terminated by a semicolon.</p>
<p>When written back out, code inside of a "block" nonterminal is indented. In the XML representing the code, the tag representing a block may contain tags for other nonterminals. A good example of a block in C++ is a code block, surrounded by a pair of curly braces.</p>
<p>For nonterminals of type none, no tag will appear for the nonterminal in the XML representing the code, however the nonterminal may still be used to build up other nonterminals. A good example of a nonterminal of type none would be a digit containing terminals 0-9 that could be used to build up integers or floating point numbers.</p>
<p>tag - Optional. If set to "yes" then the nonterminal will be written back out like an xml tag, with opening and closing braces, and a trailing slash. The name of the nonterminal will be used as the tag name. Also, any attributes other than "value" that were added to the nonterminal will also be written out. The start, end, and type attributes are also observed.</p>
<p>Examples: </p><pre class="fragment">&lt;definition name="code_block" type="block" start="{" end="}"&gt;
    ... other tags ...
&lt;/definition&gt;

&lt;definition name="statement" type="line" end=";"&gt;
    ... other tags ...
&lt;/definition&gt;

&lt;definition name="expression" type="inline"&gt;
    ... other tags ...
&lt;/definition&gt;

&lt;definition name="integer" type="literal"&gt;
    ... other tags ...
&lt;/definition&gt;

&lt;definition name="digit" type="none"&gt;
    ... other tags ...
&lt;/definition&gt;
</pre><p>The &lt;terminal&gt; tag refers to a terminal and has the following attributes: </p><pre class="fragment">value - The text of the terminal.  Ascii characters or XML entities
        can be used.  To specify the end of a line, use XML entity
        &amp;#10; (newline).  To specify the beginning of a line, use
        XML entity &amp;#2; (start of text).

case - Whether the terminal is case-sensitive or not.  Acceptable values
       are true or false.  Defaults to false.

Examples:

    &lt;terminal value="1"/&gt;
    &lt;terminal value="A"/&gt;
    &lt;terminal value="&amp;#224;"/&gt;
    &lt;terminal value="||"/&gt;
    &lt;terminal value="&amp;&amp;"/&gt;
    &lt;terminal value="class" case="false"/&gt;
    &lt;terminal value="&amp;#2;class"/&gt;
    &lt;terminal value="class&amp;#10;"/&gt;
</pre><p>The &lt;letter&gt; tag refers to an alphabetic character, either upper or lower case. It is more efficient to use the &lt;letter&gt; tag than to define a nonterminal for an alphabetic character containing terminals for each character.</p>
<p>The &lt;lowercaseletter&gt; tag refers to a lower-case alphabetic character. It is more efficient to use the &lt;lowercaseletter&gt; tag than to define a nonterminal for an alphabetic character containing terminals for each character.</p>
<p>The &lt;uppercaseletter&gt; tag refers to a upper-case alphabetic character. It is more efficient to use the &lt;uppercaseletter&gt; tag than to define a nonterminal for an alphabetic character containing terminals for each character.</p>
<p>The &lt;digit&gt; tag refers to a numeric digit. It is more efficient to use the &lt;digit&gt; tag than to define a nonterminal for a digit containing terminals for each digit.</p>
<p>The &lt;set&gt; tag defines a set of ascii characters or XML entities. It is more efficient to use the &lt;set&gt; tag than to define a nonterminal for the set containing terminals for each ascii character or XML entity. </p><pre class="fragment">value - The set of ascii characters or XML entities to match.

Example:

   &lt;definition name="symbol" type="none"&gt;
       &lt;set value="~`!@#$%^&amp;amp;*()_-+=[{]}|\;:'&amp;quot;,&amp;lt;.&amp;gt;/? "/&gt;
   &lt;/definition&gt;
</pre><p>The &lt;nonterminal&gt; tag refers to a nonterminal defined elsewhere in the grammar and has the following attributes: </p><pre class="fragment">name - The name of the nonterminal.

Examples:

    &lt;nonterminal name="code_block"/&gt;
    &lt;nonterminal name="statement"/&gt;
    &lt;nonterminal name="expression"/&gt;
    &lt;nonterminal name="integer"/&gt;
</pre><p>The &lt;alternation&gt; tag indicates to the parser that one of the enclosed tags must evaluate successfully for parsing to continue.</p>
<p>The &lt;repetition&gt; tag indicates to the parser that the enclosed tag may be evaluated zero or more times and that parsing should loop until it parses unsuccessfully.</p>
<p>The &lt;concatenation&gt; tag indicates to the parser that all of the enclosed tags must evaluate succussfully, in the specified order, when parsing the code for parsing to continue.</p>
<p>The &lt;option&gt; tag indicates to the parser that the enclosed tag may or may not evaluate succussfully and parsing should continue in either case.</p>
<p>The  tag defines an exception to the previous tag.</p>
<p>The &lt;break&gt; tag defines a terminal that, if found, will cause the enclosing repetition to stop iterating. This is useful when looking for a particular set of terminating characters which would otherwise be found by one of the sibling nonterminals. </p><pre class="fragment">Example:
An XML comment starts with but can consist of
any characters, digits or symbols internally.  In the definition below,
without the &lt;break&gt;, the nonterminal "symbol" would consume the --&gt; and
the rest of the nonterminals would likely consume the entire rest of
the XML.

    &lt;definition name="xmlcomment" type="line"
                            start="&amp;lt;-- " end=" --&amp;gt;"&gt;
        &lt;concatenation&gt;
            &lt;terminal value="&amp;lt;-- "/&gt;
            &lt;repetition&gt;
                &lt;alternation&gt;
                    &lt;break value=" --&amp;gt;"/&gt;
                    &lt;nonterminal name="alphabetic_character"/&gt;
                    &lt;nonterminal name="digit"/&gt;
                    &lt;nonterminal name="symbol"/&gt;
                    &lt;nonterminal name="whitespace"/&gt;
                &lt;/alternation&gt;
            &lt;/repetition&gt;
            &lt;terminal value=" --&amp;gt;"/&gt;
        &lt;/concatenation&gt;
    &lt;/definition&gt;
</pre><p>The break tag has the following attributes: </p><pre class="fragment">value - The text of the break.  Ascii characters or XML entities
        can be used.  To specify the end of a line, use XML entity
        &amp;#10; (newline).  To specify the beginning of a line, use
        XML entity &amp;#2; (start of text).

case - Whether the break text is case-sensitive or not.  Acceptable
       values are true or false.  Defaults to false.

recursive - Acceptable values are true or false.  Defaults to false.
            When set false, the parser only looks for the break text
            at the point that it is defined.  When set true, the parser
            looks for the break text when parsing siblings as well.

            In the above example, the parser would only look for " --&gt;"
            at the beginning of each repetition.  This is fine if each
            of the nonterminals only processes a single character.

            But, if the nonterminal "symbol" looked for a string of
            symbols rather than a single symbol, the break would need to
            be defined as recursive or the parser would miss it if it
            ran into something like "! --&gt;".
</pre><p>These tags may be used together to define nonterminals and ultimately a set of nonterminals may be used to define a grammar. </p><pre class="fragment">&lt;grammar&gt;

    &lt;definition name="digit" type="none"&gt;
        &lt;alternation&gt;
            &lt;terminal value="0"&gt;
            &lt;terminal value="1"&gt;
            &lt;terminal value="2"&gt;
            &lt;terminal value="3"&gt;
            &lt;terminal value="4"&gt;
            &lt;terminal value="5"&gt;
            &lt;terminal value="6"&gt;
            &lt;terminal value="7"&gt;
            &lt;terminal value="8"&gt;
            &lt;terminal value="9"&gt;
        &lt;/alternation&gt;
    &lt;/definition&gt;

    &lt;definition name="digit_excluding_zero" type="none"&gt;
        &lt;nonterminal name="digit"/&gt;
        &lt;exception&gt;
            &lt;terminal value="0"/&gt;
        &lt;/exception&gt;
    &lt;/definition&gt;

    &lt;definition name="integer" type="literal"&gt;
        &lt;alternation&gt;
            &lt;terminal value="0"/&gt;
            &lt;concatenation&gt;
                &lt;option&gt;
                    &lt;terminal value="-"/&gt;
                &lt;/option&gt;
                &lt;concatenation&gt;
                    &lt;nonterminal name="digit_excluding_zero"/&gt;
                    &lt;repetition&gt;
                        &lt;nonterminal name="digit"/&gt;
                    &lt;/repetition&gt;
                &lt;/concatenation&gt;
            &lt;/concatenation&gt;
        &lt;/alternation&gt;
    &lt;/definition&gt;

&lt;/grammar&gt;</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7f2c7af6c092cabdbfb513fc10f3f9b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">codetree::codetree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new instance of the codetree class. </p>

</div>
</div>
<a class="anchor" id="a7c772b1a8603ec6d6cae0e6781123459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">codetree::~codetree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes this instance of the codetree class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad74666bc86ad0906654dd32c11aed7ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> codetree::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>grammar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>startsymbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxmldomnode.html">xmldomnode</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>codeposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses "input" using "grammar", starting with "startsymbol", creates an XML represenataion of the code and appends it as children to "output". Returns true if parsing succeeded and false otherwise. If parsing fails, "codeposition" is set to the location in the code that parsing failed. </p>

</div>
</div>
<a class="anchor" id="afcb3a793828ca95aca4ef3e7557d8d95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> codetree::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcodetreegrammar.html">codetreegrammar</a> *&#160;</td>
          <td class="paramname"><em>grammar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>startsymbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxmldomnode.html">xmldomnode</a> *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>codeposition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses "input" using "grammar", starting with "startsymbol", creates an XML represenataion of the code and appends it as children to "output". Returns true if parsing succeeded and false otherwise. If parsing fails, "codeposition" is set to the location in the code that parsing failed. </p>

</div>
</div>
<a class="anchor" id="a7002d26f36e0b3fa462a3a5ebad4c43f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void codetree::setDebugLevel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>debuglevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the debug level. Debug is written to standard out. </p>

</div>
</div>
<a class="anchor" id="a81eb083aaf46b6af532c7fa772b13a63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> codetree::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmldomnode.html">xmldomnode</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>grammar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstringbuffer.html">stringbuffer</a> *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interprets the XML representation of the code "input" using "grammar" and appends it as code to "output". Returns true if this succeeds and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a4b8875f36c1b319f2eacd860b214b4c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> codetree::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmldomnode.html">xmldomnode</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcodetreegrammar.html">codetreegrammar</a> *&#160;</td>
          <td class="paramname"><em>grammar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstringbuffer.html">stringbuffer</a> *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interprets the XML representation of the code "input" using "grammar" and appends it as code to "output". Returns true if this succeeds and false otherwise. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 10 2015 00:29:09 for Rudiments by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
