<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Rudiments: memorymap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Rudiments
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmemorymap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">memorymap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac6d0af10f875a79a69288d1eb5c4a2d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#ac6d0af10f875a79a69288d1eb5c4a2d3">memorymap</a> ()</td></tr>
<tr class="separator:ac6d0af10f875a79a69288d1eb5c4a2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4454e8a1cc50b1e9f92ae322504e5a9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a4454e8a1cc50b1e9f92ae322504e5a9f">~memorymap</a> ()</td></tr>
<tr class="separator:a4454e8a1cc50b1e9f92ae322504e5a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb20bd062f7de18828835b29fc969bbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#adb20bd062f7de18828835b29fc969bbf">attach</a> (int32_t fd, off64_t offset, size_t len, int32_t protection, int32_t flags)</td></tr>
<tr class="separator:adb20bd062f7de18828835b29fc969bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d4bd745ee74c49eefe94e6b4ce1f2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a82d4bd745ee74c49eefe94e6b4ce1f2e">detach</a> ()</td></tr>
<tr class="separator:a82d4bd745ee74c49eefe94e6b4ce1f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8662dec2c28e3b7e2caaf49e13d0515f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a8662dec2c28e3b7e2caaf49e13d0515f">setProtection</a> (int32_t protection)</td></tr>
<tr class="separator:a8662dec2c28e3b7e2caaf49e13d0515f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7b93ed08f3b3b6aff3670419ebb2b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a3a7b93ed08f3b3b6aff3670419ebb2b8">setProtection</a> (off64_t offset, size_t len, int32_t protection)</td></tr>
<tr class="separator:a3a7b93ed08f3b3b6aff3670419ebb2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79ea1b438991d60320545b9549121d8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#af79ea1b438991d60320545b9549121d8">getData</a> ()</td></tr>
<tr class="separator:af79ea1b438991d60320545b9549121d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cc718b608df9d979f9d5864df2a9f8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a23cc718b608df9d979f9d5864df2a9f8">getLength</a> ()</td></tr>
<tr class="separator:a23cc718b608df9d979f9d5864df2a9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fefb03160907092f2f2239dc249204"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a56fefb03160907092f2f2239dc249204">sync</a> (<a class="el" href="classbool.html">bool</a> immediate, <a class="el" href="classbool.html">bool</a> invalidate)</td></tr>
<tr class="separator:a56fefb03160907092f2f2239dc249204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a1e915ab271493077a0ca42a8a30c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#aa5a1e915ab271493077a0ca42a8a30c8">sync</a> (off64_t offset, size_t len, <a class="el" href="classbool.html">bool</a> immediate, <a class="el" href="classbool.html">bool</a> invalidate)</td></tr>
<tr class="separator:aa5a1e915ab271493077a0ca42a8a30c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0da11f344c4dd46b19af222f22d0d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#ab0da11f344c4dd46b19af222f22d0d7e">sequentialAccess</a> (off64_t offset, size_t len)</td></tr>
<tr class="separator:ab0da11f344c4dd46b19af222f22d0d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebc7e32b4903b6770d9ba8c662324ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a4ebc7e32b4903b6770d9ba8c662324ef">randomAccess</a> (off64_t offset, size_t len)</td></tr>
<tr class="separator:a4ebc7e32b4903b6770d9ba8c662324ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23458a4355efc0e8d19747ddb5641e0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a23458a4355efc0e8d19747ddb5641e0f">willNeed</a> (off64_t offset, size_t len)</td></tr>
<tr class="separator:a23458a4355efc0e8d19747ddb5641e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c85050e392d57913a06fceaf4b9e06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#ae0c85050e392d57913a06fceaf4b9e06">wontNeed</a> (off64_t offset, size_t len)</td></tr>
<tr class="separator:ae0c85050e392d57913a06fceaf4b9e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a01f2a4284d35993351ff37d0682a3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a7a01f2a4284d35993351ff37d0682a3e">normalAccess</a> (off64_t offset, size_t len)</td></tr>
<tr class="separator:a7a01f2a4284d35993351ff37d0682a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427982521a778516549ca246d7dc566f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a427982521a778516549ca246d7dc566f">lock</a> ()</td></tr>
<tr class="separator:a427982521a778516549ca246d7dc566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e04f9463e7e8373a14a15d0aeaf65f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a3e04f9463e7e8373a14a15d0aeaf65f7">lock</a> (off64_t offset, size_t len)</td></tr>
<tr class="separator:a3e04f9463e7e8373a14a15d0aeaf65f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343dbd8057a9eaa43e2ef61816095cfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a343dbd8057a9eaa43e2ef61816095cfd">unlock</a> ()</td></tr>
<tr class="separator:a343dbd8057a9eaa43e2ef61816095cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de27acd2bcfeeba2cc526867279c4c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a7de27acd2bcfeeba2cc526867279c4c0">unlock</a> (off64_t offset, size_t len)</td></tr>
<tr class="separator:a7de27acd2bcfeeba2cc526867279c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13f1b3ab92f3c5d6b27402691412a69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#ae13f1b3ab92f3c5d6b27402691412a69">inMemory</a> ()</td></tr>
<tr class="separator:ae13f1b3ab92f3c5d6b27402691412a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57630e15cf1a626f6fc7229de2378b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a57630e15cf1a626f6fc7229de2378b4b">inMemory</a> (off64_t offset, size_t len)</td></tr>
<tr class="separator:a57630e15cf1a626f6fc7229de2378b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a113c6732bd790da458c048fa514f4ad4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a113c6732bd790da458c048fa514f4ad4">lockAll</a> ()</td></tr>
<tr class="separator:a113c6732bd790da458c048fa514f4ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5f664c557eabb283f0895f91b2add2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a5e5f664c557eabb283f0895f91b2add2">lockAllCurrent</a> ()</td></tr>
<tr class="separator:a5e5f664c557eabb283f0895f91b2add2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58047372332e473988cc7bca300a3d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#ab58047372332e473988cc7bca300a3d6">lockAllFuture</a> ()</td></tr>
<tr class="separator:ab58047372332e473988cc7bca300a3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839ef54f30dd6cc60b458a69a8024285"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmemorymap.html#a839ef54f30dd6cc60b458a69a8024285">unlockAll</a> ()</td></tr>
<tr class="separator:a839ef54f30dd6cc60b458a69a8024285"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The memorymap class provides methods for mapping a file (or file descriptor) to a region of memory and manipulating the mapped region. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac6d0af10f875a79a69288d1eb5c4a2d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">memorymap::memorymap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an instance of the memorymap class. </p>

</div>
</div>
<a class="anchor" id="a4454e8a1cc50b1e9f92ae322504e5a9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">memorymap::~memorymap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes this instance of the memorymap class, calling <a class="el" href="classmemorymap.html#a82d4bd745ee74c49eefe94e6b4ce1f2e">detach()</a> if necessary. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adb20bd062f7de18828835b29fc969bbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::attach </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>protection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attaches the memorymap to file descriptor "fd" at "offset" for "len" bytes.</p>
<p>"protection" may be: PROT_NONE - pages may not be accessed or an or'ed combination of the following: PROT_EXEC - pages may be excuted PROT_READ - pages may be read PROT_WRITE - pages may be written "protection" may not conflict with the open mode of the file. (eg. if the file was opened readonly then PROT_WRITE may not be used).</p>
<p>flags may be: MAP_SHARED or MAP_PRIVATE and an or'ed combination of the following: MAP_FIXED MAP_DENYWRITE MAP_EXECUTABLE MAP_NORESERVE MAP_LOCKED MAP_GROWSDOWN MAP_ANONYMOUS MAP_ANON MAP_32BIT MAP_AUTOGROW MAP_AUTORESRV MAP_COPY MAP_LOCAL</p>
<p>Note that not all filesystems support all of those options.</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a82d4bd745ee74c49eefe94e6b4ce1f2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>detaches the memory map from the file descriptor</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="af79ea1b438991d60320545b9549121d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* memorymap::getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the region of memory that the file is mapped into. </p>

</div>
</div>
<a class="anchor" id="a23cc718b608df9d979f9d5864df2a9f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t memorymap::getLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the region of memory that the file is mapped into. </p>

</div>
</div>
<a class="anchor" id="ae13f1b3ab92f3c5d6b27402691412a69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::inMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if all pages of the memory map are currently cached in system ram. Returns true on success and false on failure.</p>
<p>On systems that don't support checking whether pages of the memory map are currently cached in system ram, this method returns false. </p>

</div>
</div>
<a class="anchor" id="a57630e15cf1a626f6fc7229de2378b4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::inMemory </td>
          <td>(</td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if all pages of the memory map starting at "offset", for "len" bytes are currently cached in system ram. Returns true on success and false on failure.</p>
<p>On systems that don't support checking whether pages of the memory map are currently cached in system ram, this method returns false. </p>

</div>
</div>
<a class="anchor" id="a427982521a778516549ca246d7dc566f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables paging of the entire memory map. Returns true on success and false on failure.</p>
<p>On systems that don't support locking, this method returns false. </p>

</div>
</div>
<a class="anchor" id="a3e04f9463e7e8373a14a15d0aeaf65f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::lock </td>
          <td>(</td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables paging of data in the memory map, starting at "offset", for "len" bytes. Returns true on success and false on failure.</p>
<p>On systems that don't support locking, this method returns false. </p>

</div>
</div>
<a class="anchor" id="a113c6732bd790da458c048fa514f4ad4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> memorymap::lockAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disables paging (storing to swap partition) of all pages of memory currently used for memorymaps by the process and all newly allocated pages. Returns true on success and false on failure.</p>
<p>On systems that don't support locking, this method returns false; </p>

</div>
</div>
<a class="anchor" id="a5e5f664c557eabb283f0895f91b2add2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> memorymap::lockAllCurrent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disables paging (storing to swap partition) of all pages of memory currently used for memorymaps by the process. Newly allocated pages may still be paged out. Returns true on success and false on failure.</p>
<p>On systems that don't support locking, this method returns false; </p>

</div>
</div>
<a class="anchor" id="ab58047372332e473988cc7bca300a3d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> memorymap::lockAllFuture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disables paging (storing to swap partition) of all newly allocated pages of memory used for memorymaps by the process. Currently allocated pages may still be paged out. Returns true on success and false on failure.</p>
<p>On systems that don't support locking, this method returns false; </p>

</div>
</div>
<a class="anchor" id="a7a01f2a4284d35993351ff37d0682a3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::normalAccess </td>
          <td>(</td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advises the kernel that you are going to access the region of the currently mapped file begining at byte "offset", for "len" bytes, normally so the kernel can undo any previously applied optimizations.</p>
<p>Returns true on success and false on failure.</p>
<p>On operating systems don't support this method, it returns true but don't actually do anything. </p>

</div>
</div>
<a class="anchor" id="a4ebc7e32b4903b6770d9ba8c662324ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::randomAccess </td>
          <td>(</td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advises the kernel that you are going to access the region of the currently mapped file begining at byte "offset", for "len" bytes, randomly so the kernel can perform some optimizations.</p>
<p>Returns true on success and false on failure.</p>
<p>On operating systems don't support this method, it returns true but don't actually do anything. </p>

</div>
</div>
<a class="anchor" id="ab0da11f344c4dd46b19af222f22d0d7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::sequentialAccess </td>
          <td>(</td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advises the kernel that you are going to access the region of the currently mapped file begining at byte "offset", for "len" bytes, sequentially so the kernel can perform some optimizations.</p>
<p>Returns true on success and false on failure.</p>
<p>On operating systems don't support this method, it returns true but don't actually do anything. </p>

</div>
</div>
<a class="anchor" id="a8662dec2c28e3b7e2caaf49e13d0515f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::setProtection </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>protection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the protection of the entire memory map to "protection". See protect() below for more info. </p>

</div>
</div>
<a class="anchor" id="a3a7b93ed08f3b3b6aff3670419ebb2b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::setProtection </td>
          <td>(</td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>protection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the protection of the memory map to "protection" for "len" bytes, starting at "offset".</p>
<p>"protection" may be: PROT_NONE - pages may not be accessed or an or'ed combination of the following: PROT_EXEC - pages may be excuted PROT_READ - pages may be read PROT_WRITE - pages may be written "protection" may not conflict with the open mode of the file. (eg. if the file was opened readonly then PROT_WRITE may not be used).</p>
<p>Note that not all filesystems support all of those options.</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a56fefb03160907092f2f2239dc249204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::sync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>immediate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>invalidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make sure that changes made to the memory map have been copied to the storage mediam that the mapped file resides on.</p>
<p>If "immediate" is true, the method will not return until the synchronization has finished, if it is false, the synchronization will occur in the background.</p>
<p>If "invalidate" is true, all other mappings of the file will be invalidated.</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="aa5a1e915ab271493077a0ca42a8a30c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::sync </td>
          <td>(</td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>immediate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>invalidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make sure that changes made to the memory map for "len" bytes, starting at "offset" have been copied to the storage mediam that the mapped file resides on.</p>
<p>If "immediate" is true, the method will not return until the synchronization has finished, if it is false, the synchronization will occur in the background.</p>
<p>If "invalidate" is true, all other mappings of the file will be invalidated.</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a343dbd8057a9eaa43e2ef61816095cfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables paging of the entire memory map. Returns true on success and false on failure.</p>
<p>On systems that don't support locking, this method returns false. </p>

</div>
</div>
<a class="anchor" id="a7de27acd2bcfeeba2cc526867279c4c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::unlock </td>
          <td>(</td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables paging of data in the memory map, starting at "offset", for "len" bytes. Returns true on success and false on failure.</p>
<p>On systems that don't support locking, this method returns false. </p>

</div>
</div>
<a class="anchor" id="a839ef54f30dd6cc60b458a69a8024285"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> memorymap::unlockAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enables paging of data stored in all memorymaps currently open by the process. Returns true on success and false on failure.</p>
<p>On systems that don't support locking, this method returns false; </p>

</div>
</div>
<a class="anchor" id="a23458a4355efc0e8d19747ddb5641e0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::willNeed </td>
          <td>(</td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advises the kernel that you are going to access the region of the currently mapped file begining at byte "offset", for "len" bytes, in the near future so the kernel can perform some optimizations.</p>
<p>Returns true on success and false on failure.</p>
<p>On operating systems don't support this method, it returns true but don't actually do anything. </p>

</div>
</div>
<a class="anchor" id="ae0c85050e392d57913a06fceaf4b9e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> memorymap::wontNeed </td>
          <td>(</td>
          <td class="paramtype">off64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advises the kernel that you are not going to access the region of the currently mapped file begining at byte "offset", for "len" bytes, in the near future so the kernel can perform some optimizations.</p>
<p>Returns true on success and false on failure.</p>
<p>On operating systems don't support this method, it returns true but don't actually do anything. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 21 2016 02:12:48 for Rudiments by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
