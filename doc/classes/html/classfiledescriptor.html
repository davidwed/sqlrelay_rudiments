<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Rudiments: filedescriptor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rudiments
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classfiledescriptor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">filedescriptor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherited by <a class="el" href="classclient.html">client</a>, <a class="el" href="classfile.html">file</a>, <a class="el" href="classserialport.html">serialport</a>, <a class="el" href="classserver.html">server</a>, and <a class="el" href="classstdiofiledescriptor.html">stdiofiledescriptor</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0179c81bbcb0c39bfe822a8b4f726a32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a0179c81bbcb0c39bfe822a8b4f726a32">filedescriptor</a> ()</td></tr>
<tr class="separator:a0179c81bbcb0c39bfe822a8b4f726a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a55f4c684b0151d0088018d8dcc0267"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8a55f4c684b0151d0088018d8dcc0267">filedescriptor</a> (const <a class="el" href="classfiledescriptor.html">filedescriptor</a> &amp;f)</td></tr>
<tr class="separator:a8a55f4c684b0151d0088018d8dcc0267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337e115dbf9075d2e06890cb85d09e2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfiledescriptor.html">filedescriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a337e115dbf9075d2e06890cb85d09e2d">operator=</a> (const <a class="el" href="classfiledescriptor.html">filedescriptor</a> &amp;f)</td></tr>
<tr class="separator:a337e115dbf9075d2e06890cb85d09e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7e2d6dd54324862720e600c3342b89"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ade7e2d6dd54324862720e600c3342b89">~filedescriptor</a> ()</td></tr>
<tr class="separator:ade7e2d6dd54324862720e600c3342b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67442522f75c98d34ce5778ab5eeb754"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a67442522f75c98d34ce5778ab5eeb754">close</a> ()</td></tr>
<tr class="separator:a67442522f75c98d34ce5778ab5eeb754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedff2b95cfac65447dac45b35539387f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aedff2b95cfac65447dac45b35539387f">getFileDescriptor</a> () const </td></tr>
<tr class="separator:aedff2b95cfac65447dac45b35539387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e38ff382e70ed0993fcb087aae86ca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5e38ff382e70ed0993fcb087aae86ca0">setFileDescriptor</a> (int32_t filedesc)</td></tr>
<tr class="separator:a5e38ff382e70ed0993fcb087aae86ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad967e6cbdaa87b8df42dc1636d119675"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ad967e6cbdaa87b8df42dc1636d119675">duplicate</a> () const </td></tr>
<tr class="separator:ad967e6cbdaa87b8df42dc1636d119675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a2f0627c0214cfac74de0c28fb0b7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a45a2f0627c0214cfac74de0c28fb0b7c">duplicate</a> (int32_t newfd) const </td></tr>
<tr class="separator:a45a2f0627c0214cfac74de0c28fb0b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e077d4780acd07b63932897a81f6a4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a4e077d4780acd07b63932897a81f6a4f">setSecurityContext</a> (<a class="el" href="classsecuritycontext.html">securitycontext</a> *ctx)</td></tr>
<tr class="separator:a4e077d4780acd07b63932897a81f6a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3090f0d9aad119a6f4a121313cac579"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsecuritycontext.html">securitycontext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ad3090f0d9aad119a6f4a121313cac579">getSecurityContext</a> ()</td></tr>
<tr class="separator:ad3090f0d9aad119a6f4a121313cac579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9a7fa52d49184adda885bf76e1197b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aba9a7fa52d49184adda885bf76e1197b">supportsBlockingNonBlockingModes</a> ()</td></tr>
<tr class="separator:aba9a7fa52d49184adda885bf76e1197b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab914af53fa7d8165ff05ce1b3649eff6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab914af53fa7d8165ff05ce1b3649eff6">useNonBlockingMode</a> () const </td></tr>
<tr class="separator:ab914af53fa7d8165ff05ce1b3649eff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3686bb24f4e1d57092479481efa3519"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ae3686bb24f4e1d57092479481efa3519">useBlockingMode</a> () const </td></tr>
<tr class="separator:ae3686bb24f4e1d57092479481efa3519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73fe66c335c7b8cdd04ea881416bfeb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab73fe66c335c7b8cdd04ea881416bfeb">isUsingNonBlockingMode</a> () const </td></tr>
<tr class="separator:ab73fe66c335c7b8cdd04ea881416bfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe28a94af94bce6122c606072da0cd04"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write</a> (uint16_t number) const </td></tr>
<tr class="separator:abe28a94af94bce6122c606072da0cd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a7e2def89d670256dc3a0df8a29391"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a47a7e2def89d670256dc3a0df8a29391">write</a> (uint32_t number) const </td></tr>
<tr class="separator:a47a7e2def89d670256dc3a0df8a29391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74daeedb23c083e536b8f75dc526bf75"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a74daeedb23c083e536b8f75dc526bf75">write</a> (uint64_t number) const </td></tr>
<tr class="separator:a74daeedb23c083e536b8f75dc526bf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88822c3260b2ee9213e7d17fa8d103b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ae88822c3260b2ee9213e7d17fa8d103b">write</a> (int16_t number) const </td></tr>
<tr class="separator:ae88822c3260b2ee9213e7d17fa8d103b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b8575e395d4d28b4933f251fafa4f0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a87b8575e395d4d28b4933f251fafa4f0">write</a> (int32_t number) const </td></tr>
<tr class="separator:a87b8575e395d4d28b4933f251fafa4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceeaa5027a4383b4e87063475e144c52"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aceeaa5027a4383b4e87063475e144c52">write</a> (int64_t number) const </td></tr>
<tr class="separator:aceeaa5027a4383b4e87063475e144c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f764a75ac0c47bc8b9d85792c92e57b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a1f764a75ac0c47bc8b9d85792c92e57b">write</a> (float number) const </td></tr>
<tr class="separator:a1f764a75ac0c47bc8b9d85792c92e57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3098a6dffccde3117a38f9c94e421f64"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a3098a6dffccde3117a38f9c94e421f64">write</a> (double number) const </td></tr>
<tr class="separator:a3098a6dffccde3117a38f9c94e421f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877787f3d7eed67798d8e8adc6e56507"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a877787f3d7eed67798d8e8adc6e56507">write</a> (unsigned char <a class="el" href="classcharacter.html">character</a>) const </td></tr>
<tr class="separator:a877787f3d7eed67798d8e8adc6e56507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84835e964733d718a316b89568da06a4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a84835e964733d718a316b89568da06a4">write</a> (char <a class="el" href="classcharacter.html">character</a>) const </td></tr>
<tr class="separator:a84835e964733d718a316b89568da06a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3503f5346ab56f79d3c3a9b24b33254"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab3503f5346ab56f79d3c3a9b24b33254">write</a> (<a class="el" href="classbool.html">bool</a> value) const </td></tr>
<tr class="separator:ab3503f5346ab56f79d3c3a9b24b33254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7deae4623e5bc5075ffb52eb653757"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a6c7deae4623e5bc5075ffb52eb653757">write</a> (const unsigned char *string) const </td></tr>
<tr class="separator:a6c7deae4623e5bc5075ffb52eb653757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4034d9728aeac0c8cb21666ff30b2eb4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a4034d9728aeac0c8cb21666ff30b2eb4">write</a> (const char *string) const </td></tr>
<tr class="separator:a4034d9728aeac0c8cb21666ff30b2eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa40f30ef6d8a5645779e926e96aa1c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8fa40f30ef6d8a5645779e926e96aa1c">write</a> (const unsigned char *string, size_t size) const </td></tr>
<tr class="separator:a8fa40f30ef6d8a5645779e926e96aa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fe7090449a9115376cddb500f1bd39"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a09fe7090449a9115376cddb500f1bd39">write</a> (const char *string, size_t size) const </td></tr>
<tr class="separator:a09fe7090449a9115376cddb500f1bd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758b1955a7d9cb6b4d13068ee4f5ea8a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a758b1955a7d9cb6b4d13068ee4f5ea8a">write</a> (const void *buffer, size_t size) const </td></tr>
<tr class="separator:a758b1955a7d9cb6b4d13068ee4f5ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ac7bc445194b0f7006136688326564"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a51ac7bc445194b0f7006136688326564">write</a> (uint16_t number, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:a51ac7bc445194b0f7006136688326564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d65d19e41a0854dbdb0ea61463d2c3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac4d65d19e41a0854dbdb0ea61463d2c3">write</a> (uint32_t number, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:ac4d65d19e41a0854dbdb0ea61463d2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9815b856f24e9df5d60fbae79d3031"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abe9815b856f24e9df5d60fbae79d3031">write</a> (uint64_t number, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:abe9815b856f24e9df5d60fbae79d3031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d959a3ab38ae275f471045251e0c702"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a0d959a3ab38ae275f471045251e0c702">write</a> (int16_t number, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:a0d959a3ab38ae275f471045251e0c702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af841513fc4c4d19a52e617e3c2bf773f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#af841513fc4c4d19a52e617e3c2bf773f">write</a> (int32_t number, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:af841513fc4c4d19a52e617e3c2bf773f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad3cd3d199d88f09ef9e1e5a3799e11"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a1ad3cd3d199d88f09ef9e1e5a3799e11">write</a> (int64_t number, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:a1ad3cd3d199d88f09ef9e1e5a3799e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20519c2fabaf8753cf6e3d164f53b987"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a20519c2fabaf8753cf6e3d164f53b987">write</a> (float number, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:a20519c2fabaf8753cf6e3d164f53b987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a946f54e2759ddf31c621700781df1a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7a946f54e2759ddf31c621700781df1a">write</a> (double number, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:a7a946f54e2759ddf31c621700781df1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae91c8f98d8988cd4b59b2274a08591"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#afae91c8f98d8988cd4b59b2274a08591">write</a> (unsigned char <a class="el" href="classcharacter.html">character</a>, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:afae91c8f98d8988cd4b59b2274a08591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04df3a27d85ed63ce53fc0242b9c7e85"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a04df3a27d85ed63ce53fc0242b9c7e85">write</a> (char <a class="el" href="classcharacter.html">character</a>, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:a04df3a27d85ed63ce53fc0242b9c7e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24abc07ce533d9681853c204d38a0d97"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a24abc07ce533d9681853c204d38a0d97">write</a> (<a class="el" href="classbool.html">bool</a> value, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:a24abc07ce533d9681853c204d38a0d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa035da4e48feeda1e5aaafd07125b79c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aa035da4e48feeda1e5aaafd07125b79c">write</a> (const unsigned char *string, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:aa035da4e48feeda1e5aaafd07125b79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a88accb70e09ef7b9c23ae2c62a86a6"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7a88accb70e09ef7b9c23ae2c62a86a6">write</a> (const char *string, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:a7a88accb70e09ef7b9c23ae2c62a86a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc6fdf16c302e16875902435f46339b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#acbc6fdf16c302e16875902435f46339b">write</a> (const unsigned char *string, size_t size, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:acbc6fdf16c302e16875902435f46339b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d53b1e0798ba2c029e2551f73959ee"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a25d53b1e0798ba2c029e2551f73959ee">write</a> (const char *string, size_t size, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:a25d53b1e0798ba2c029e2551f73959ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad639846f2ab073fe2ff7633095c36d30"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ad639846f2ab073fe2ff7633095c36d30">write</a> (const void *buffer, size_t size, int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:ad639846f2ab073fe2ff7633095c36d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1be69125ca1da2e29fd879ddec0884"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aee1be69125ca1da2e29fd879ddec0884">printf</a> (const char *format,...)</td></tr>
<tr class="separator:aee1be69125ca1da2e29fd879ddec0884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca45a396d6fa9539b2c5bff9a522cdc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abca45a396d6fa9539b2c5bff9a522cdc">printf</a> (const char *format, va_list *argp)</td></tr>
<tr class="separator:abca45a396d6fa9539b2c5bff9a522cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c3f71354b52187c7ec3694c852dfb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a32c3f71354b52187c7ec3694c852dfb5">safePrint</a> (unsigned char c)</td></tr>
<tr class="separator:a32c3f71354b52187c7ec3694c852dfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8928f8d17a17fa07abd5aa67f720270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aa8928f8d17a17fa07abd5aa67f720270">safePrint</a> (const unsigned char *str)</td></tr>
<tr class="separator:aa8928f8d17a17fa07abd5aa67f720270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb2d518dbf4385aafc90440d9ffc634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a6fb2d518dbf4385aafc90440d9ffc634">safePrint</a> (const unsigned char *str, int32_t length)</td></tr>
<tr class="separator:a6fb2d518dbf4385aafc90440d9ffc634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe4d7a5f7cc9647918f2e82ea92f607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#acfe4d7a5f7cc9647918f2e82ea92f607">safePrint</a> (char c)</td></tr>
<tr class="separator:acfe4d7a5f7cc9647918f2e82ea92f607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ec1b7bfa7f1cea47fbaa51ab19274c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ad8ec1b7bfa7f1cea47fbaa51ab19274c">safePrint</a> (const char *str)</td></tr>
<tr class="separator:ad8ec1b7bfa7f1cea47fbaa51ab19274c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7ab52f6588fed5d3333a2846123781"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#afc7ab52f6588fed5d3333a2846123781">safePrint</a> (const char *str, int32_t length)</td></tr>
<tr class="separator:afc7ab52f6588fed5d3333a2846123781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f53235cab047b201d2b1f72e2be49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a0d1f53235cab047b201d2b1f72e2be49">printBits</a> (unsigned char value)</td></tr>
<tr class="separator:a0d1f53235cab047b201d2b1f72e2be49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdc9f2b00210abdf388228d090d0c25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#acfdc9f2b00210abdf388228d090d0c25">printBits</a> (uint16_t value)</td></tr>
<tr class="separator:acfdc9f2b00210abdf388228d090d0c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ac6483472155ceb5369c78056cdd2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac1ac6483472155ceb5369c78056cdd2e">printBits</a> (uint32_t value)</td></tr>
<tr class="separator:ac1ac6483472155ceb5369c78056cdd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa92fd29704514169bd24bc83a1eafa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a2aa92fd29704514169bd24bc83a1eafa">printBits</a> (uint64_t value)</td></tr>
<tr class="separator:a2aa92fd29704514169bd24bc83a1eafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a68aa9a4c182dac401c6d2dd73dc016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5a68aa9a4c182dac401c6d2dd73dc016">printBits</a> (char value)</td></tr>
<tr class="separator:a5a68aa9a4c182dac401c6d2dd73dc016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d6d654d0ab3087fba7031852a1a7fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a67d6d654d0ab3087fba7031852a1a7fc">printBits</a> (int16_t value)</td></tr>
<tr class="separator:a67d6d654d0ab3087fba7031852a1a7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d99a64aa7ebe3d03649a92e865d023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a83d99a64aa7ebe3d03649a92e865d023">printBits</a> (int32_t value)</td></tr>
<tr class="separator:a83d99a64aa7ebe3d03649a92e865d023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb55da4b2c387d5fe42da1a85a26ee54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#adb55da4b2c387d5fe42da1a85a26ee54">printBits</a> (int64_t value)</td></tr>
<tr class="separator:adb55da4b2c387d5fe42da1a85a26ee54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc6e16e78b4cfbeb41f8c10678d6d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abffc6e16e78b4cfbeb41f8c10678d6d7">printBits</a> (unsigned char *bits, uint64_t size)</td></tr>
<tr class="separator:abffc6e16e78b4cfbeb41f8c10678d6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf81fad5ccb63d72f7ba7f712df1efa"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aacf81fad5ccb63d72f7ba7f712df1efa">read</a> (uint16_t *buffer)</td></tr>
<tr class="separator:aacf81fad5ccb63d72f7ba7f712df1efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f30e76bb676d2cbb73fd0a72eb8867"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a67f30e76bb676d2cbb73fd0a72eb8867">read</a> (uint32_t *buffer)</td></tr>
<tr class="separator:a67f30e76bb676d2cbb73fd0a72eb8867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef819a27c37151fc7963f1593118716"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5ef819a27c37151fc7963f1593118716">read</a> (uint64_t *buffer)</td></tr>
<tr class="separator:a5ef819a27c37151fc7963f1593118716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c992dc6437d3dd50f45ac599990605f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a0c992dc6437d3dd50f45ac599990605f">read</a> (int16_t *buffer)</td></tr>
<tr class="separator:a0c992dc6437d3dd50f45ac599990605f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f204e578954bdf4268ec46907a3203e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5f204e578954bdf4268ec46907a3203e">read</a> (int32_t *buffer)</td></tr>
<tr class="separator:a5f204e578954bdf4268ec46907a3203e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfb18c5f8dbf9269431d2ec58256bd5"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aadfb18c5f8dbf9269431d2ec58256bd5">read</a> (int64_t *buffer)</td></tr>
<tr class="separator:aadfb18c5f8dbf9269431d2ec58256bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c44e0e6c35042a42dd55aab46f48078"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8c44e0e6c35042a42dd55aab46f48078">read</a> (float *buffer)</td></tr>
<tr class="separator:a8c44e0e6c35042a42dd55aab46f48078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ec1b1c1585ef4ee96abcd41f6dd366"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a16ec1b1c1585ef4ee96abcd41f6dd366">read</a> (double *buffer)</td></tr>
<tr class="separator:a16ec1b1c1585ef4ee96abcd41f6dd366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63060a1053bdbb70a2814fdd368c89e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab63060a1053bdbb70a2814fdd368c89e">read</a> (unsigned char *buffer)</td></tr>
<tr class="separator:ab63060a1053bdbb70a2814fdd368c89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5003cb19b376218a3205610d5b089a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5b5003cb19b376218a3205610d5b089a">read</a> (char *buffer)</td></tr>
<tr class="separator:a5b5003cb19b376218a3205610d5b089a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2968dfd28631bcd14842acbb59fb4f0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab2968dfd28631bcd14842acbb59fb4f0">read</a> (<a class="el" href="classbool.html">bool</a> *buffer)</td></tr>
<tr class="separator:ab2968dfd28631bcd14842acbb59fb4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712b366b22a90650cc173eb6bbbf1037"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a712b366b22a90650cc173eb6bbbf1037">read</a> (unsigned char *buffer, size_t size)</td></tr>
<tr class="separator:a712b366b22a90650cc173eb6bbbf1037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a80e6b528a15d5e030bf348b4bd0e7b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a4a80e6b528a15d5e030bf348b4bd0e7b">read</a> (char *buffer, size_t size)</td></tr>
<tr class="separator:a4a80e6b528a15d5e030bf348b4bd0e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87df2e118ebb74c9f65d77a0bcf55e65"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a87df2e118ebb74c9f65d77a0bcf55e65">read</a> (void *buf, size_t size)</td></tr>
<tr class="separator:a87df2e118ebb74c9f65d77a0bcf55e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b64514c6e024cbd6ec538ce08ed771"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ad7b64514c6e024cbd6ec538ce08ed771">read</a> (char **buffer, const char *terminator)</td></tr>
<tr class="separator:ad7b64514c6e024cbd6ec538ce08ed771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5179d7895da1dbf3477a0e65ad6ecb50"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5179d7895da1dbf3477a0e65ad6ecb50">read</a> (char **buffer, const char *terminator, size_t maxbytes)</td></tr>
<tr class="separator:a5179d7895da1dbf3477a0e65ad6ecb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcaff602914bb419067a1b159bd2a9d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#affcaff602914bb419067a1b159bd2a9d">read</a> (uint16_t *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:affcaff602914bb419067a1b159bd2a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60c856df5bac9eb9037d308315b30bc"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#af60c856df5bac9eb9037d308315b30bc">read</a> (uint32_t *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:af60c856df5bac9eb9037d308315b30bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa960c8e6abef55216c3a0aa7d3158a1a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aa960c8e6abef55216c3a0aa7d3158a1a">read</a> (uint64_t *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:aa960c8e6abef55216c3a0aa7d3158a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7dd17160f01317c8b0bdacc0e8a286"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a3c7dd17160f01317c8b0bdacc0e8a286">read</a> (int16_t *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a3c7dd17160f01317c8b0bdacc0e8a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdca5992cbb14ea3a9cb0e8e7cca4d4b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abdca5992cbb14ea3a9cb0e8e7cca4d4b">read</a> (int32_t *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:abdca5992cbb14ea3a9cb0e8e7cca4d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4caed5c82e66678f0d7b95912db0ad"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a6c4caed5c82e66678f0d7b95912db0ad">read</a> (int64_t *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a6c4caed5c82e66678f0d7b95912db0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f956b7b98ff1eaaafe49ac4bf85954b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a2f956b7b98ff1eaaafe49ac4bf85954b">read</a> (float *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a2f956b7b98ff1eaaafe49ac4bf85954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada13a76fdab6354c2b2d88f722d52d4c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ada13a76fdab6354c2b2d88f722d52d4c">read</a> (double *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:ada13a76fdab6354c2b2d88f722d52d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a94803aceb83d3c07149e92e21f6dc4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a4a94803aceb83d3c07149e92e21f6dc4">read</a> (unsigned char *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a4a94803aceb83d3c07149e92e21f6dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3462cf7e6c9db3fbb694a8dc4eb7dbb0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a3462cf7e6c9db3fbb694a8dc4eb7dbb0">read</a> (char *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a3462cf7e6c9db3fbb694a8dc4eb7dbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dc9912f5b19233ddcf9dd4a245d774"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a65dc9912f5b19233ddcf9dd4a245d774">read</a> (<a class="el" href="classbool.html">bool</a> *buffer, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a65dc9912f5b19233ddcf9dd4a245d774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038993c3205f44d2a232e4ecbef847a9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a038993c3205f44d2a232e4ecbef847a9">read</a> (unsigned char *buffer, size_t size, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a038993c3205f44d2a232e4ecbef847a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c74799053cf78ae985bc1a184b7082"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a89c74799053cf78ae985bc1a184b7082">read</a> (char *buffer, size_t size, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a89c74799053cf78ae985bc1a184b7082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072a781c4583084d3a03d712c071c877"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a072a781c4583084d3a03d712c071c877">read</a> (void *buf, size_t size, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a072a781c4583084d3a03d712c071c877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507e0211882750c6fa0294dc1fc21ac0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a507e0211882750c6fa0294dc1fc21ac0">read</a> (char **buffer, const char *terminator, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a507e0211882750c6fa0294dc1fc21ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce9102385702bbd239ead9b0c6d406d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8ce9102385702bbd239ead9b0c6d406d">read</a> (char **buffer, const char *terminator, size_t maxbytes, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a8ce9102385702bbd239ead9b0c6d406d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65350b341135bde22a8253497eb5a547"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a65350b341135bde22a8253497eb5a547">read</a> (char **buffer, const char *terminator, size_t maxbytes, char escapechar, int32_t sec, int32_t usec)</td></tr>
<tr class="separator:a65350b341135bde22a8253497eb5a547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1213f59d6676b3b89dcada76a02920"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a4a1213f59d6676b3b89dcada76a02920">waitForNonBlockingRead</a> (int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:a4a1213f59d6676b3b89dcada76a02920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea21b1cd210b2ad1da8c8f3ea27650dc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aea21b1cd210b2ad1da8c8f3ea27650dc">waitForNonBlockingWrite</a> (int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:aea21b1cd210b2ad1da8c8f3ea27650dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873da850bf73716babe080f7fa723784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a873da850bf73716babe080f7fa723784">retryInterruptedReads</a> ()</td></tr>
<tr class="separator:a873da850bf73716babe080f7fa723784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7311c4fa746bcf1f75f076264c308b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7f7311c4fa746bcf1f75f076264c308b">dontRetryInterruptedReads</a> ()</td></tr>
<tr class="separator:a7f7311c4fa746bcf1f75f076264c308b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac093fef061ead93c17eb6aa84eecf46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac093fef061ead93c17eb6aa84eecf46e">getRetryInterruptedReads</a> () const </td></tr>
<tr class="separator:ac093fef061ead93c17eb6aa84eecf46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac372c3c60abd093ea7a0b70c74e30f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac372c3c60abd093ea7a0b70c74e30f9b">retryInterruptedWrites</a> ()</td></tr>
<tr class="separator:ac372c3c60abd093ea7a0b70c74e30f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70cc7d8e024f7bb6bf8fc926067d9ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac70cc7d8e024f7bb6bf8fc926067d9ba">dontRetryInterruptedWrites</a> ()</td></tr>
<tr class="separator:ac70cc7d8e024f7bb6bf8fc926067d9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2b7e9cf7baef94d507e04e0a8e7f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7e2b7e9cf7baef94d507e04e0a8e7f45">getRetryInterruptedWrites</a> () const </td></tr>
<tr class="separator:a7e2b7e9cf7baef94d507e04e0a8e7f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f560f93d4b1ee57a7332b19588d3af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ae6f560f93d4b1ee57a7332b19588d3af">retryInterruptedWaits</a> ()</td></tr>
<tr class="separator:ae6f560f93d4b1ee57a7332b19588d3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879e0146d88f66e6188442e8b4b1cb8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a879e0146d88f66e6188442e8b4b1cb8b">dontRetryInterruptedWaits</a> ()</td></tr>
<tr class="separator:a879e0146d88f66e6188442e8b4b1cb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b145e4eafb11d8c89eb7efa8738c196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a9b145e4eafb11d8c89eb7efa8738c196">getRetryInterruptedWaits</a> () const </td></tr>
<tr class="separator:a9b145e4eafb11d8c89eb7efa8738c196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced1588c0b772a96548b8b1a737199c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aced1588c0b772a96548b8b1a737199c2">retryInterruptedFcntl</a> ()</td></tr>
<tr class="separator:aced1588c0b772a96548b8b1a737199c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dd611bf1ab97bfff2c14535a403f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a32dd611bf1ab97bfff2c14535a403f74">dontRetryInterruptedFcntl</a> ()</td></tr>
<tr class="separator:a32dd611bf1ab97bfff2c14535a403f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14cc0aa8cc1b849917b1547c5948ef5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aa14cc0aa8cc1b849917b1547c5948ef5">getRetryInterruptedFcntl</a> () const </td></tr>
<tr class="separator:aa14cc0aa8cc1b849917b1547c5948ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e322411718595166970dc371981457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a08e322411718595166970dc371981457">retryInterruptedIoctl</a> ()</td></tr>
<tr class="separator:a08e322411718595166970dc371981457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e1255f92ef1f93396a2badabe8998b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a50e1255f92ef1f93396a2badabe8998b">dontRetryInterruptedIoctl</a> ()</td></tr>
<tr class="separator:a50e1255f92ef1f93396a2badabe8998b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695f7c309d62a020a5cf3b2fd3021c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a695f7c309d62a020a5cf3b2fd3021c7a">getRetryInterruptedIoctl</a> () const </td></tr>
<tr class="separator:a695f7c309d62a020a5cf3b2fd3021c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8385bed0f0586feb7129ffa3ce5e5c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8385bed0f0586feb7129ffa3ce5e5c55">allowShortReads</a> ()</td></tr>
<tr class="separator:a8385bed0f0586feb7129ffa3ce5e5c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450567c8744e8162832cfc325051ee6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a450567c8744e8162832cfc325051ee6e">dontAllowShortReads</a> ()</td></tr>
<tr class="separator:a450567c8744e8162832cfc325051ee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7c22612b0dd31718fac688d896b084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abe7c22612b0dd31718fac688d896b084">allowShortWrites</a> ()</td></tr>
<tr class="separator:abe7c22612b0dd31718fac688d896b084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5585ce27c88d29da92e37aa23f027e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5585ce27c88d29da92e37aa23f027e1b">dontAllowShortWrites</a> ()</td></tr>
<tr class="separator:a5585ce27c88d29da92e37aa23f027e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fe84f596f3f7858b58342c53745f62"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a20fe84f596f3f7858b58342c53745f62">passFileDescriptor</a> (int32_t fd)</td></tr>
<tr class="separator:a20fe84f596f3f7858b58342c53745f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2631e6bcb28f671c9476f879c2d26c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#afa2631e6bcb28f671c9476f879c2d26c">receiveFileDescriptor</a> (int32_t *fd)</td></tr>
<tr class="separator:afa2631e6bcb28f671c9476f879c2d26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78ff24aa4496d326d079add756f6a42"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab78ff24aa4496d326d079add756f6a42">passSocket</a> (int32_t sock)</td></tr>
<tr class="separator:ab78ff24aa4496d326d079add756f6a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0606bdff7f7e6902b03f58b27f5f8bf5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a0606bdff7f7e6902b03f58b27f5f8bf5">receiveSocket</a> (int32_t *sock)</td></tr>
<tr class="separator:a0606bdff7f7e6902b03f58b27f5f8bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c42991f500b7fc1ef01fcdf0f240fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a50c42991f500b7fc1ef01fcdf0f240fd">translateByteOrder</a> ()</td></tr>
<tr class="separator:a50c42991f500b7fc1ef01fcdf0f240fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2ea19fa8e4d360f969f0446a556f2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5a2ea19fa8e4d360f969f0446a556f2a">dontTranslateByteOrder</a> ()</td></tr>
<tr class="separator:a5a2ea19fa8e4d360f969f0446a556f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2a0bff4d68644295536ed69e71e205"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ace2a0bff4d68644295536ed69e71e205">fCntl</a> (int32_t command, long arg) const </td></tr>
<tr class="separator:ace2a0bff4d68644295536ed69e71e205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0b6913b4e150f1f5e5b1561493d496"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7f0b6913b4e150f1f5e5b1561493d496">ioCtl</a> (int32_t command, void *arg) const </td></tr>
<tr class="separator:a7f0b6913b4e150f1f5e5b1561493d496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d4f98f00a3794e44bafb8c94f7b906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a68d4f98f00a3794e44bafb8c94f7b906">useNaglesAlgorithm</a> ()</td></tr>
<tr class="separator:a68d4f98f00a3794e44bafb8c94f7b906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cd844190971abebd6af838f1b2becb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a40cd844190971abebd6af838f1b2becb">dontUseNaglesAlgorithm</a> ()</td></tr>
<tr class="separator:a40cd844190971abebd6af838f1b2becb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e149613647efa0e87963f07479e7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a92e149613647efa0e87963f07479e7d9">setTcpWriteBufferSize</a> (int32_t size)</td></tr>
<tr class="separator:a92e149613647efa0e87963f07479e7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c6293f0c320922e46d4662e5d2e85f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a65c6293f0c320922e46d4662e5d2e85f">getTcpWriteBufferSize</a> (int32_t *size)</td></tr>
<tr class="separator:a65c6293f0c320922e46d4662e5d2e85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd820738744ec4723be54351b026339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7cd820738744ec4723be54351b026339">setTcpReadBufferSize</a> (int32_t size)</td></tr>
<tr class="separator:a7cd820738744ec4723be54351b026339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf0a1af7a070fe41262d39d0ec23281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5bf0a1af7a070fe41262d39d0ec23281">getTcpReadBufferSize</a> (int32_t *size)</td></tr>
<tr class="separator:a5bf0a1af7a070fe41262d39d0ec23281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af992db5c1593ee697f99953000c0f429"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#af992db5c1593ee697f99953000c0f429">disableIPv4</a> ()</td></tr>
<tr class="separator:af992db5c1593ee697f99953000c0f429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab859b86a0907beb82513acc5985ce625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab859b86a0907beb82513acc5985ce625">enableIPv4</a> ()</td></tr>
<tr class="separator:ab859b86a0907beb82513acc5985ce625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2e40bd232c70c7a6dae2ab01ddbba0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a0f2e40bd232c70c7a6dae2ab01ddbba0">getType</a> () const </td></tr>
<tr class="separator:a0f2e40bd232c70c7a6dae2ab01ddbba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0589e7427841901e23c840124cc3e69"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac0589e7427841901e23c840124cc3e69">getPeerAddress</a> () const </td></tr>
<tr class="separator:ac0589e7427841901e23c840124cc3e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d62107de57c6670c508571d43b4b21f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7d62107de57c6670c508571d43b4b21f">setWriteBufferSize</a> (ssize_t size) const </td></tr>
<tr class="separator:a7d62107de57c6670c508571d43b4b21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba629d9b99f13febf0fb18dca29d78b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aeba629d9b99f13febf0fb18dca29d78b">flushWriteBuffer</a> (int32_t sec, int32_t usec) const </td></tr>
<tr class="separator:aeba629d9b99f13febf0fb18dca29d78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c400e8cfb189433b98848a18ae061"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a074c400e8cfb189433b98848a18ae061">setReadBufferSize</a> (ssize_t size) const </td></tr>
<tr class="separator:a074c400e8cfb189433b98848a18ae061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8620a165895ff4e8a433e4539c10955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aa8620a165895ff4e8a433e4539c10955">closeOnExec</a> ()</td></tr>
<tr class="separator:aa8620a165895ff4e8a433e4539c10955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72033e31c0cbe18602b9a21e9493b590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a72033e31c0cbe18602b9a21e9493b590">dontCloseOnExec</a> ()</td></tr>
<tr class="separator:a72033e31c0cbe18602b9a21e9493b590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3f857b7f6ee423a39640c5dc2ebfee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a2d3f857b7f6ee423a39640c5dc2ebfee">getCloseOnExec</a> ()</td></tr>
<tr class="separator:a2d3f857b7f6ee423a39640c5dc2ebfee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a015c15b53476f7741d4693481a0b2a96"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a015c15b53476f7741d4693481a0b2a96">hostToNet</a> (uint16_t value)</td></tr>
<tr class="separator:a015c15b53476f7741d4693481a0b2a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dd118e7f10d87de4300ac399bd1272"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab0dd118e7f10d87de4300ac399bd1272">hostToNet</a> (uint32_t value)</td></tr>
<tr class="separator:ab0dd118e7f10d87de4300ac399bd1272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231c459ea091720cb70b7b1b071fc132"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a231c459ea091720cb70b7b1b071fc132">hostToNet</a> (uint64_t value)</td></tr>
<tr class="separator:a231c459ea091720cb70b7b1b071fc132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687405f4614390bb3bf6ad91ea0a709a"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a687405f4614390bb3bf6ad91ea0a709a">netToHost</a> (uint16_t value)</td></tr>
<tr class="separator:a687405f4614390bb3bf6ad91ea0a709a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f43ceb482795d7a26631ba836fe9d3"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a04f43ceb482795d7a26631ba836fe9d3">netToHost</a> (uint32_t value)</td></tr>
<tr class="separator:a04f43ceb482795d7a26631ba836fe9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf96fd9d695c8bc46a8d6a73d620c7b8"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abf96fd9d695c8bc46a8d6a73d620c7b8">netToHost</a> (uint64_t value)</td></tr>
<tr class="separator:abf96fd9d695c8bc46a8d6a73d620c7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The filedescriptor class is a base class for other classes that utilize file descriptors. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0179c81bbcb0c39bfe822a8b4f726a32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">filedescriptor::filedescriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an instance of the filedescriptor class. </p>

</div>
</div>
<a class="anchor" id="a8a55f4c684b0151d0088018d8dcc0267"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">filedescriptor::filedescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfiledescriptor.html">filedescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an instance of the filedescriptor class that is a copy of "f". </p>

</div>
</div>
<a class="anchor" id="ade7e2d6dd54324862720e600c3342b89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual filedescriptor::~filedescriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this instance of the filedescriptor class. Calls <a class="el" href="classfiledescriptor.html#a67442522f75c98d34ce5778ab5eeb754">close()</a> if it hasn't already been called. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8385bed0f0586feb7129ffa3ce5e5c55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::allowShortReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, <a class="el" href="classfiledescriptor.html#aacf81fad5ccb63d72f7ba7f712df1efa">read()</a> will attempt to read the specified number of bytes from the file descriptor, even if several passes are necessary.</p>
<p>This method causes a <a class="el" href="classfiledescriptor.html#aacf81fad5ccb63d72f7ba7f712df1efa">read()</a> to attempt only a single pass and return the number of bytes that were read during that pass whether the specified number of bytes were read or not.</p>
<p>Note that reads longer than SSIZE_MAX will only attempt to read SSIZE_MAX bytes. </p>

</div>
</div>
<a class="anchor" id="abe7c22612b0dd31718fac688d896b084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::allowShortWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> will attempt to write the specified number of bytes from the file descriptor, in several passes if necessary.</p>
<p>This method causes a <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> to attempt only a single pass and return the number of bytes that were written during that pass whether the specified number of bytes were written or not.</p>
<p>Note that writes longer than SSIZE_MAX will only attempt to write SSIZE_MAX bytes. </p>

</div>
</div>
<a class="anchor" id="a67442522f75c98d34ce5778ab5eeb754"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> filedescriptor::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closes the file descriptor. Returns true on success and false on failure. </p>

<p>Reimplemented in <a class="el" href="classunixsocketclient.html#a1b261c44a4a59db0e944a82478d64d57">unixsocketclient</a>, <a class="el" href="classmodemserver.html#aa101470691771ea8935cff08a07062ec">modemserver</a>, and <a class="el" href="classmodemclient.html#a59da1ccad2a46ae4b49eb7190b95d955">modemclient</a>.</p>

</div>
</div>
<a class="anchor" id="aa8620a165895ff4e8a433e4539c10955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::closeOnExec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the close-on-exec status is false (the default), then the file descriptor will remain open across an execve() call, otherwise it will be closed.</p>
<p>This method sets the close-on-exec status to true. </p>

</div>
</div>
<a class="anchor" id="af992db5c1593ee697f99953000c0f429"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::disableIPv4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables IPv4 on this file descriptor, only IPv6 will be used. This is only useful for TCP Socket file descriptors. Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a450567c8744e8162832cfc325051ee6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontAllowShortReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, <a class="el" href="classfiledescriptor.html#aacf81fad5ccb63d72f7ba7f712df1efa">read()</a> will attempt to read the specified number of bytes from the file descriptor, even if several passes are necessary.</p>
<p>This method causes that default behavior to be observed. </p>

</div>
</div>
<a class="anchor" id="a5585ce27c88d29da92e37aa23f027e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontAllowShortWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> will attempt to write the specified number of bytes from the file descriptor, even if several passes are necessary.</p>
<p>This method causes that default behavior to be observed. </p>

</div>
</div>
<a class="anchor" id="a72033e31c0cbe18602b9a21e9493b590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::dontCloseOnExec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the close-on-exec status is false (the default), then the file descriptor will remain open across an execve() call, otherwise it will be closed.</p>
<p>This method sets the close-on-exec status to false (the default). </p>

</div>
</div>
<a class="anchor" id="a32dd611bf1ab97bfff2c14535a403f74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontRetryInterruptedFcntl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes fcntl operations not to be automatically retried if interrupted by a signal. If this is set, a fcntl is occurring and a signal interrupts it, the fcntl fails, the system error is set to EINTR and the fcntl must be retried. </p>

</div>
</div>
<a class="anchor" id="a50e1255f92ef1f93396a2badabe8998b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontRetryInterruptedIoctl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes ioctl operations not to be automatically retried if interrupted by a signal. If this is set, a ioctl is occurring and a signal interrupts it, the ioctl fails, the system error is set to EINTR and the ioctl must be retried. </p>

</div>
</div>
<a class="anchor" id="a7f7311c4fa746bcf1f75f076264c308b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontRetryInterruptedReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes reads not to automatically retry if interrupted by a signal. This is the default behavior. By default, if a read is occurring and a signal interrupts it, the read fails, the system error is set to EINTR and the read must be retried. </p>

</div>
</div>
<a class="anchor" id="a879e0146d88f66e6188442e8b4b1cb8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontRetryInterruptedWaits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes wait operations not to be automatically retried if interrupted by a signal. If this is set, a wait is occurring and a signal interrupts it, the wait fails, the system error is set to EINTR and the wait must be retried. </p>

</div>
</div>
<a class="anchor" id="ac70cc7d8e024f7bb6bf8fc926067d9ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontRetryInterruptedWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes writes not to automatically retry if interrupted by a signal. This is the default behavior. By default, if a write is occurring and a signal interrupts it, the write fails, the system error is set to EINTR and the write must be retried. </p>

</div>
</div>
<a class="anchor" id="a5a2ea19fa8e4d360f969f0446a556f2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontTranslateByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Don't translate integers from native byte order to network byte order during writes and vice-versa during reads. This is the default behavior. </p>

</div>
</div>
<a class="anchor" id="a40cd844190971abebd6af838f1b2becb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::dontUseNaglesAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes all <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a>'s to be sent immediately. (disables Nagle's algorithm)</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="ad967e6cbdaa87b8df42dc1636d119675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t filedescriptor::duplicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicates the file descriptor and returns the handle of the duplicate descriptor. The old and new descriptors may be used interchangeably, they share locks, position pointers, flags (except the close-on-exec flag), etc.</p>
<p>Returns the lowest-numbered unused descriptor on success or -1 on failure. </p>

</div>
</div>
<a class="anchor" id="a45a2f0627c0214cfac74de0c28fb0b7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::duplicate </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>newfd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets file descriptor handle "newfd" to be a duplicate of this file descriptor. If "newfd" is already open, it will be closed first.</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="ab859b86a0907beb82513acc5985ce625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::enableIPv4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables IPv4 (in addition to IPv6) on this file descriptor (the default). This is only useful for TCP Socket file descriptors. Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="ace2a0bff4d68644295536ed69e71e205"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t filedescriptor::fCntl </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the fcntl() system call to perform various low-level file descriptor operations. </p>

</div>
</div>
<a class="anchor" id="aeba629d9b99f13febf0fb18dca29d78b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::flushWriteBuffer </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If an application does many small writes, the overhead of all of those system calls can slow the application down substantially. To address that issue, the filedescriptor class can buffer data passed in to any of it's <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> methods and only make system calls when the buffer is full or when it's flushed manually. Note that when using buffered writes, no data is actually written to the file descriptor until the buffer is full or until it's flushed manually.</p>
<p>Do not confuse this buffer with the tcp write buffer. The tcp write buffer resides in kernel space, is populated by the <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> system call in an analagous manner and is used to minimize network latency, not application latency due to system calls. This buffer is in user space and populated prior to the <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> system call.</p>
<p>This method causes the contents of the write buffer to be written to the filedescriptor immediately.</p>
<p>Returns true on success and false on failure.</p>
<p>If the buffer cannot be flushed within "sec" seconds and "usec" microseconds, then the method will fail. Set either "sec" or "usec" to -1 to disable the timeout and allow the method to block until the buffer has been flushed. </p>

</div>
</div>
<a class="anchor" id="a2d3f857b7f6ee423a39640c5dc2ebfee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::getCloseOnExec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the close-on-exec status is false (the default), then the file descriptor will remain open across an execve() call, otherwise it will be closed.</p>
<p>This method returns true if the close-on-exec status is set to true and false otherwise. </p>

</div>
</div>
<a class="anchor" id="aedff2b95cfac65447dac45b35539387f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t filedescriptor::getFileDescriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the file descriptor. </p>

</div>
</div>
<a class="anchor" id="ac0589e7427841901e23c840124cc3e69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* filedescriptor::getPeerAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the IP address of the client at the other end of the connection if the filedescriptor is an inet socket or NULL otherwise.</p>
<p>Note that the buffer for the address is allocated internally and must be freed by the calling program. </p>

</div>
</div>
<a class="anchor" id="aa14cc0aa8cc1b849917b1547c5948ef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::getRetryInterruptedFcntl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if interrupted calls to fcntl will be retried and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a695f7c309d62a020a5cf3b2fd3021c7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::getRetryInterruptedIoctl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if interrupted calls to ioctl will be retried and false otherwise. </p>

</div>
</div>
<a class="anchor" id="ac093fef061ead93c17eb6aa84eecf46e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::getRetryInterruptedReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if interrupted reads will be retried and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a9b145e4eafb11d8c89eb7efa8738c196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::getRetryInterruptedWaits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if interrupted waits will be retried and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a7e2b7e9cf7baef94d507e04e0a8e7f45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::getRetryInterruptedWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if interrupted writes will be retried and false otherwise. </p>

</div>
</div>
<a class="anchor" id="ad3090f0d9aad119a6f4a121313cac579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsecuritycontext.html">securitycontext</a>* filedescriptor::getSecurityContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the securitycontext currently associated with the filedescriptor or NULL if none is currently associated. </p>

</div>
</div>
<a class="anchor" id="a5bf0a1af7a070fe41262d39d0ec23281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::getTcpReadBufferSize </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the size of the kernel's TCP read buffer (in bytes) into buffer "size". This is only useful for TCP socket file descriptors. Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a65c6293f0c320922e46d4662e5d2e85f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::getTcpWriteBufferSize </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the size of the kernel's TCP write buffer (in bytes) into buffer "size". This is only useful for TCP socket file descriptors. Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a0f2e40bd232c70c7a6dae2ab01ddbba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* filedescriptor::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string representing the type of the filedescriptor. This is "filedescriptor" by default but a child class may override this method and return something else. </p>

</div>
</div>
<a class="anchor" id="a015c15b53476f7741d4693481a0b2a96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t filedescriptor::hostToNet </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 16-bit integer from host byte order to network byte order. </p>

</div>
</div>
<a class="anchor" id="ab0dd118e7f10d87de4300ac399bd1272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t filedescriptor::hostToNet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 32-bit integer from host byte order to network byte order. </p>

</div>
</div>
<a class="anchor" id="a231c459ea091720cb70b7b1b071fc132"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t filedescriptor::hostToNet </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 64-bit integer from host byte order to network byte order. </p>

</div>
</div>
<a class="anchor" id="a7f0b6913b4e150f1f5e5b1561493d496"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t filedescriptor::ioCtl </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use the ioctl() system call to perform various low-level file descriptor operations. </p>

<p>Reimplemented in <a class="el" href="classsocketserver.html#ac0340611ab5b372da89bde604671f509">socketserver</a>, and <a class="el" href="classsocketclient.html#a893ad27d36667df606a718dccd5364b1">socketclient</a>.</p>

</div>
</div>
<a class="anchor" id="ab73fe66c335c7b8cdd04ea881416bfeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> filedescriptor::isUsingNonBlockingMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the file descriptor is in non-blocking mode and false otherwise. </p>

<p>Reimplemented in <a class="el" href="classsocketserver.html#ac433ec189408754385bf8fa6e5c9ce5e">socketserver</a>, and <a class="el" href="classsocketclient.html#adf84386f7f51ac6f0f742bbd38b68898">socketclient</a>.</p>

</div>
</div>
<a class="anchor" id="a687405f4614390bb3bf6ad91ea0a709a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t filedescriptor::netToHost </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 16-bit integer from network byte order to host byte order. </p>

</div>
</div>
<a class="anchor" id="a04f43ceb482795d7a26631ba836fe9d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t filedescriptor::netToHost </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 32-bit integer from network byte order to host byte order. </p>

</div>
</div>
<a class="anchor" id="abf96fd9d695c8bc46a8d6a73d620c7b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t filedescriptor::netToHost </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 64-bit integer from network byte order to host byte order. </p>

</div>
</div>
<a class="anchor" id="a337e115dbf9075d2e06890cb85d09e2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfiledescriptor.html">filedescriptor</a>&amp; filedescriptor::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfiledescriptor.html">filedescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes this instance of the filedescriptor class identical to "f". </p>

</div>
</div>
<a class="anchor" id="a20fe84f596f3f7858b58342c53745f62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> filedescriptor::passFileDescriptor </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sends file descriptor "fd" to the file descriptor. This is useful for passing an open file descriptor from one process to another over a unix socket, for example. </p>

</div>
</div>
<a class="anchor" id="ab78ff24aa4496d326d079add756f6a42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> filedescriptor::passSocket </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sends socket "sock" to the file descriptor. This is useful for passing an open socket from one process to another over a unix socket, for example. </p>

</div>
</div>
<a class="anchor" id="a0d1f53235cab047b201d2b1f72e2be49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::printBits </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "value" to the file descriptor as a string of ones and zeros. </p>

</div>
</div>
<a class="anchor" id="acfdc9f2b00210abdf388228d090d0c25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::printBits </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "value" to the file descriptor as a string of ones and zeros. </p>

</div>
</div>
<a class="anchor" id="ac1ac6483472155ceb5369c78056cdd2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::printBits </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "value" to the file descriptor as a string of ones and zeros. </p>

</div>
</div>
<a class="anchor" id="a2aa92fd29704514169bd24bc83a1eafa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::printBits </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "value" to the file descriptor as a string of ones and zeros. </p>

</div>
</div>
<a class="anchor" id="a5a68aa9a4c182dac401c6d2dd73dc016"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::printBits </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "value" to the file descriptor as a string of ones and zeros. </p>

</div>
</div>
<a class="anchor" id="a67d6d654d0ab3087fba7031852a1a7fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::printBits </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "value" to the file descriptor as a string of ones and zeros. </p>

</div>
</div>
<a class="anchor" id="a83d99a64aa7ebe3d03649a92e865d023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::printBits </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "value" to the file descriptor as a string of ones and zeros. </p>

</div>
</div>
<a class="anchor" id="adb55da4b2c387d5fe42da1a85a26ee54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::printBits </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "value" to the file descriptor as a string of ones and zeros. </p>

</div>
</div>
<a class="anchor" id="abffc6e16e78b4cfbeb41f8c10678d6d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::printBits </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "value" to the file descriptor as a string of ones and zeros. </p>

</div>
</div>
<a class="anchor" id="aee1be69125ca1da2e29fd879ddec0884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t filedescriptor::printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "..." to the filedescriptor using "format" which should comply with standard printf formatting rules. </p>

</div>
</div>
<a class="anchor" id="abca45a396d6fa9539b2c5bff9a522cdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t filedescriptor::printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list *&#160;</td>
          <td class="paramname"><em>argp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "argp" to the filedescriptor using "format" which should comply with standard printf formatting rules.</p>
<p>Note that argp is a pointer to a va_list, not just a va_list. </p>

</div>
</div>
<a class="anchor" id="aacf81fad5ccb63d72f7ba7f712df1efa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 16-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a67f30e76bb676d2cbb73fd0a72eb8867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 32-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a5ef819a27c37151fc7963f1593118716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 64-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a0c992dc6437d3dd50f45ac599990605f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 16-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a5f204e578954bdf4268ec46907a3203e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 32-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="aadfb18c5f8dbf9269431d2ec58256bd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a8c44e0e6c35042a42dd55aab46f48078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a floating point number from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a16ec1b1c1585ef4ee96abcd41f6dd366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a double-precision floating point number from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="ab63060a1053bdbb70a2814fdd368c89e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned character from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a5b5003cb19b376218a3205610d5b089a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an character from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="ab2968dfd28631bcd14842acbb59fb4f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a boolean value from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a712b366b22a90650cc173eb6bbbf1037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" unsigned characters from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a4a80e6b528a15d5e030bf348b4bd0e7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" characters from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a87df2e118ebb74c9f65d77a0bcf55e65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" bytes from the file descriptor into "buf". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="ad7b64514c6e024cbd6ec538ce08ed771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads from the file desciptor into "buffer" until "terminator" is encountered.</p>
<p>Note that "buffer" is allocated internally and must be freed by the calling program.</p>
<p>Returns the number of bytes that were read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a5179d7895da1dbf3477a0e65ad6ecb50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads from the file desciptor into "buffer" until "terminator" is encountered.</p>
<p>Note that "buffer" is allocated internally and must be freed by the calling program.</p>
<p>Returns the number of bytes that were read, RESULT_ERROR if an error occurred or RESULT_MAX if maxbytes were read before the terminator was encountered.</p>
<p>Setting maxbytes to 0 disables it. </p>

</div>
</div>
<a class="anchor" id="affcaff602914bb419067a1b159bd2a9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 16-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="af60c856df5bac9eb9037d308315b30bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 32-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="aa960c8e6abef55216c3a0aa7d3158a1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 64-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a3c7dd17160f01317c8b0bdacc0e8a286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 16-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="abdca5992cbb14ea3a9cb0e8e7cca4d4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 32-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a6c4caed5c82e66678f0d7b95912db0ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a2f956b7b98ff1eaaafe49ac4bf85954b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a floating point number from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="ada13a76fdab6354c2b2d88f722d52d4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a double-precision floating point number from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a4a94803aceb83d3c07149e92e21f6dc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned character from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a3462cf7e6c9db3fbb694a8dc4eb7dbb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a character from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a65dc9912f5b19233ddcf9dd4a245d774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a boolean value from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a038993c3205f44d2a232e4ecbef847a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" unsigned characters from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a89c74799053cf78ae985bc1a184b7082"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" characters from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a072a781c4583084d3a03d712c071c877"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" bytes from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a507e0211882750c6fa0294dc1fc21ac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads from the file desciptor into "buffer" until "terminator" is encountered with a timeout of "sec" seconds and "usec" microseconds.</p>
<p>Note that "buffer" is allocated internally and must be freed by the calling program.</p>
<p>Returns the number of bytes that were read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a8ce9102385702bbd239ead9b0c6d406d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads from the file desciptor into "buffer" until "terminator" is encountered with a timeout of "sec" seconds and "usec" microseconds.</p>
<p>Note that "buffer" is allocated internally and must be freed by the calling program.</p>
<p>Returns the number of bytes that were read, RESULT_ERROR if an error occurred or RESULT_MAX if maxbytes were read before the terminator was encountered.</p>
<p>Setting maxbytes to 0 disables it. </p>

</div>
</div>
<a class="anchor" id="a65350b341135bde22a8253497eb5a547"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escapechar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads from the file desciptor into "buffer" until "terminator" is encountered, using "escapechar" as an escape character, with a timeout of "sec" seconds and "usec" microseconds.</p>
<p>Note that "buffer" is allocated internally and must be freed by the calling program.</p>
<p>Setting "escapechar" to '\0' disables it.</p>
<p>Returns the number of bytes that were read, RESULT_ERROR if an error occurred or RESULT_MAX if maxbytes were read before the terminator was encountered.</p>
<p>Setting maxbytes to 0 disables it. </p>

</div>
</div>
<a class="anchor" id="afa2631e6bcb28f671c9476f879c2d26c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> filedescriptor::receiveFileDescriptor </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Receives a file descriptor into buffer "fd". This is useful for receiving an open file descriptor passed from another process over a unix socket, for example. </p>

</div>
</div>
<a class="anchor" id="a0606bdff7f7e6902b03f58b27f5f8bf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> filedescriptor::receiveSocket </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Receives a socket into buffer "sock". This is useful for receiving an open file descriptor passed from another process over a unix socket, for example. </p>

</div>
</div>
<a class="anchor" id="aced1588c0b772a96548b8b1a737199c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::retryInterruptedFcntl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes fcntl operations to be automatically retried if interrupted by a signal. This is the default behavior. Otherwise, if a fcntl is occurring and a signal interrupts it, the fcntl fails, the system error is set to EINTR and the fcntl must be retried. </p>

</div>
</div>
<a class="anchor" id="a08e322411718595166970dc371981457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::retryInterruptedIoctl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes ioctl operations to be automatically retried if interrupted by a signal. This is the default behavior. Otherwise, if a ioctl is occurring and a signal interrupts it, the ioctl fails, the system error is set to EINTR and the ioctl must be retried. </p>

</div>
</div>
<a class="anchor" id="a873da850bf73716babe080f7fa723784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::retryInterruptedReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes reads to automatically retry if interrupted by a signal. By default, if a read is occurring and a signal interrupts it, the read fails, the system error is set to EINTR and the read must be retried. </p>

</div>
</div>
<a class="anchor" id="ae6f560f93d4b1ee57a7332b19588d3af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::retryInterruptedWaits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes wait operations to be automatically retried if interrupted by a signal. This is the default behavior. Otherwise, if a wait is occurring and a signal interrupts it, the wait fails, the system error is set to EINTR and the wait must be retried. </p>

</div>
</div>
<a class="anchor" id="ac372c3c60abd093ea7a0b70c74e30f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::retryInterruptedWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes writes to automatically retry if interrupted by a signal. By default, if a write is occurring and a signal interrupts it, the write fails, the system error is set to EINTR and the write must be retried. </p>

</div>
</div>
<a class="anchor" id="a32c3f71354b52187c7ec3694c852dfb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::safePrint </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "c" to the filedescriptor, however if "c" is non-printing character then it is printed as a hex value of the format: (0x0a). Carriage returns, line feeds and tabs are printed as <br />
,  and . </p>

</div>
</div>
<a class="anchor" id="aa8928f8d17a17fa07abd5aa67f720270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::safePrint </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "str" to the filedescriptor, however all non-printing characters are printed as hex values of the format: (0x0a) and carriage returns, line feeds and tabs are printed as <br />
,  and . </p>

</div>
</div>
<a class="anchor" id="a6fb2d518dbf4385aafc90440d9ffc634"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::safePrint </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "length" characters of "str" to the filedescriptor, however all non-printing characters are printed as hex values of the format: (0x0a) and carriage returns, line feeds and tabs are printed as <br />
,  and . </p>

</div>
</div>
<a class="anchor" id="acfe4d7a5f7cc9647918f2e82ea92f607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::safePrint </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "c" to the filedescriptor, however if "c" is non-printing character then it is printed as a hex value of the format: (0x0a). Carriage returns, line feeds and tabs are printed as <br />
,  and . </p>

</div>
</div>
<a class="anchor" id="ad8ec1b7bfa7f1cea47fbaa51ab19274c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::safePrint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "str" to the filedescriptor, however all non-printing characters are printed as hex values of the format: (0x0a) and carriage returns, line feeds and tabs are printed as <br />
,  and . </p>

</div>
</div>
<a class="anchor" id="afc7ab52f6588fed5d3333a2846123781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::safePrint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints "length" characters of "str" to the filedescriptor, however all non-printing characters are printed as hex values of the format: (0x0a) and carriage returns, line feeds and tabs are printed as <br />
,  and . </p>

</div>
</div>
<a class="anchor" id="a5e38ff382e70ed0993fcb087aae86ca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::setFileDescriptor </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>filedesc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the file descriptor associated with the class to "filedesc". </p>

</div>
</div>
<a class="anchor" id="a074c400e8cfb189433b98848a18ae061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::setReadBufferSize </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If an application does many small reads, the overhead of all of those system calls can slow the application down substantially. To address that issue, the filedescriptor class can create a read buffer and attempt to keep it full. When the first read is attempted, it will attempt to read "size" bytes into the buffer and only return the number of bytes specified in the read. Subsequent reads will just return data from the buffer without doing additional system calls unless the buffer is empty.</p>
<p>Do not confuse this buffer with the tcp read buffer. The tcp read buffer resides in kernel space, is populated by the <a class="el" href="classfiledescriptor.html#aacf81fad5ccb63d72f7ba7f712df1efa">read()</a> system call in an analagous manner and is used to minimize network latency, not application latency due to system calls. This buffer is in user space and populated in the manner described above.</p>
<p>This method sets the read buffer size to "size" bytes and returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a4e077d4780acd07b63932897a81f6a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::setSecurityContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsecuritycontext.html">securitycontext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associates a securitycontext "ctx" with the filedescriptor. To remove the current context, pass in a NULL for "ctx". </p>

</div>
</div>
<a class="anchor" id="a7cd820738744ec4723be54351b026339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::setTcpReadBufferSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the size of the kernel's TCP read buffer to "size" bytes. This is only useful for TCP socket file descriptors. Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a92e149613647efa0e87963f07479e7d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::setTcpWriteBufferSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the size of the kernel's TCP write buffer to "size" bytes. This is only useful for TCP socket file descriptors. Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a7d62107de57c6670c508571d43b4b21f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::setWriteBufferSize </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If an application does many small writes, the overhead of all of those system calls can slow the application down substantially. To address that issue, the filedescriptor class can buffer data passed in to any of it's <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> methods and only make system calls when the buffer is full or when it's flushed manually. Note that when using buffered writes, no data is actually written to the file descriptor until the buffer is full or until it's flushed manually.</p>
<p>Do not confuse this buffer with the tcp write buffer. The tcp write buffer resides in kernel space, is populated by the <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> system call and is used to minimize network latency, not application latency due to system calls. This buffer is in user space and populated prior to the <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> system call.</p>
<p>This method sets the write buffer size to "size" bytes. A size of 0 means not to buffer writes at all.</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="aba9a7fa52d49184adda885bf76e1197b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> filedescriptor::supportsBlockingNonBlockingModes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the client socket supports blocking/nonblocking modes and false otherwise. </p>

<p>Reimplemented in <a class="el" href="classsocketserver.html#af62d33f4bfb8e80c01a795d6b2aa931c">socketserver</a>, and <a class="el" href="classsocketclient.html#a837eef34e0bf89326ac4bc1c037d8fd6">socketclient</a>.</p>

</div>
</div>
<a class="anchor" id="a50c42991f500b7fc1ef01fcdf0f240fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::translateByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate integers from native byte order to network byte order during writes and vice-versa during reads. By default, no translation is done. </p>

</div>
</div>
<a class="anchor" id="ae3686bb24f4e1d57092479481efa3519"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> filedescriptor::useBlockingMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts the file descriptor in blocking mode. Returns true on success and false on failure. </p>

<p>Reimplemented in <a class="el" href="classsocketserver.html#a623dbd673ed8e4913e99907fba507690">socketserver</a>, and <a class="el" href="classsocketclient.html#ad93bfcd92f26a8e00b06972fdab87bcd">socketclient</a>.</p>

</div>
</div>
<a class="anchor" id="a68d4f98f00a3794e44bafb8c94f7b906"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> filedescriptor::useNaglesAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes small <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a>'s to be collected up and sent together when either the kernel's write buffer is full or when a maximum of 0.2 seconds has gone by. (enable Nagle's algorithm)</p>
<p>This is the default.</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="ab914af53fa7d8165ff05ce1b3649eff6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> filedescriptor::useNonBlockingMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts the file descriptor in non-blocking mode. Returns true on success and false on failure. </p>

<p>Reimplemented in <a class="el" href="classsocketserver.html#aaaedf782faa03b06d6e02b23dd42f0c9">socketserver</a>, and <a class="el" href="classsocketclient.html#a7c0c15aee27947b6ac50accb784507a0">socketclient</a>.</p>

</div>
</div>
<a class="anchor" id="a4a1213f59d6676b3b89dcada76a02920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t filedescriptor::waitForNonBlockingRead </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the application to wait until a <a class="el" href="classfiledescriptor.html#aacf81fad5ccb63d72f7ba7f712df1efa">read()</a> will proceed without blocking or until "sec" seconds and "usec" microseconds have elapsed.</p>
<p>Entering -1 for either parameter causes the method to wait indefinitely.</p>
<p>Entering 0 for both parameters causes the method to fall through immediately unless a data is immediately available.</p>
<p>Returns RESULT_ERROR on error, RESULT_TIMEOUT on timeout and otherwise returns the number of file descriptors that are ready to be read from.</p>
<p>This will usually be 1, indicating that the file descriptor represented by the class is ready to be read from. </p>

</div>
</div>
<a class="anchor" id="aea21b1cd210b2ad1da8c8f3ea27650dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t filedescriptor::waitForNonBlockingWrite </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the application to wait until a <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> will proceed without blocking or until "sec" seconds and "usec" microseconds have elapsed.</p>
<p>Entering -1 for either parameter causes the method to wait indefinitely.</p>
<p>Entering 0 for both parameters causes the method to fall through immediately unless a data is immediately available.</p>
<p>Returns RESULT_ERROR on error, RESULT_TIMEOUT on timeout and otherwise returns the number of file descriptors that are ready to be written to.</p>
<p>This will usually be 1, indicating that the file descriptor represented by the class is ready to be written to. </p>

</div>
</div>
<a class="anchor" id="abe28a94af94bce6122c606072da0cd04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a47a7e2def89d670256dc3a0df8a29391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a74daeedb23c083e536b8f75dc526bf75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="ae88822c3260b2ee9213e7d17fa8d103b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a87b8575e395d4d28b4933f251fafa4f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="aceeaa5027a4383b4e87063475e144c52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a1f764a75ac0c47bc8b9d85792c92e57b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a3098a6dffccde3117a38f9c94e421f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a877787f3d7eed67798d8e8adc6e56507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "character" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a84835e964733d718a316b89568da06a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "character" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="ab3503f5346ab56f79d3c3a9b24b33254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "value" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a6c7deae4623e5bc5075ffb52eb653757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes NULL-terminated "string" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a4034d9728aeac0c8cb21666ff30b2eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes NULL-terminated "string" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a8fa40f30ef6d8a5645779e926e96aa1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "string" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. Note that it is possible to write beyond the string's NULL terminator using this method. </p>

</div>
</div>
<a class="anchor" id="a09fe7090449a9115376cddb500f1bd39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "string" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. Note that it is possible to write beyond the string's NULL terminator using this method. </p>

</div>
</div>
<a class="anchor" id="a758b1955a7d9cb6b4d13068ee4f5ea8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "buffer" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a51ac7bc445194b0f7006136688326564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="ac4d65d19e41a0854dbdb0ea61463d2c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="abe9815b856f24e9df5d60fbae79d3031"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a0d959a3ab38ae275f471045251e0c702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="af841513fc4c4d19a52e617e3c2bf773f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a1ad3cd3d199d88f09ef9e1e5a3799e11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a20519c2fabaf8753cf6e3d164f53b987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a7a946f54e2759ddf31c621700781df1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="afae91c8f98d8988cd4b59b2274a08591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "character" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a04df3a27d85ed63ce53fc0242b9c7e85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "character" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a24abc07ce533d9681853c204d38a0d97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "value" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="aa035da4e48feeda1e5aaafd07125b79c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes NULL-terminated "string" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a7a88accb70e09ef7b9c23ae2c62a86a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes NULL-terminated "string" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="acbc6fdf16c302e16875902435f46339b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "string" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. Note that it is possible to write beyond the string's NULL terminator using this method. </p>

</div>
</div>
<a class="anchor" id="a25d53b1e0798ba2c029e2551f73959ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "string" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. Note that it is possible to write beyond the string's NULL terminator using this method. </p>

</div>
</div>
<a class="anchor" id="ad639846f2ab073fe2ff7633095c36d30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "buffer" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 16 2016 01:14:33 for Rudiments by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
