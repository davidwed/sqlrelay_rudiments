<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Rudiments: filedescriptor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Rudiments
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">filedescriptor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Inherited by <a class="el" href="classclient.html">client</a>, <a class="el" href="classfile.html">file</a>, <a class="el" href="classserialport.html">serialport</a>, and <a class="el" href="classserver.html">server</a>.</p>

<p><a href="classfiledescriptor-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0179c81bbcb0c39bfe822a8b4f726a32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a0179c81bbcb0c39bfe822a8b4f726a32">filedescriptor</a> ()</td></tr>
<tr class="memitem:a8a55f4c684b0151d0088018d8dcc0267"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8a55f4c684b0151d0088018d8dcc0267">filedescriptor</a> (const <a class="el" href="classfiledescriptor.html">filedescriptor</a> &amp;f)</td></tr>
<tr class="memitem:a337e115dbf9075d2e06890cb85d09e2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfiledescriptor.html">filedescriptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a337e115dbf9075d2e06890cb85d09e2d">operator=</a> (const <a class="el" href="classfiledescriptor.html">filedescriptor</a> &amp;f)</td></tr>
<tr class="memitem:ade7e2d6dd54324862720e600c3342b89"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ade7e2d6dd54324862720e600c3342b89">~filedescriptor</a> ()</td></tr>
<tr class="memitem:a67442522f75c98d34ce5778ab5eeb754"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a67442522f75c98d34ce5778ab5eeb754">close</a> ()</td></tr>
<tr class="memitem:aedff2b95cfac65447dac45b35539387f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aedff2b95cfac65447dac45b35539387f">getFileDescriptor</a> () const </td></tr>
<tr class="memitem:a5e38ff382e70ed0993fcb087aae86ca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5e38ff382e70ed0993fcb087aae86ca0">setFileDescriptor</a> (int32_t filedesc)</td></tr>
<tr class="memitem:ad967e6cbdaa87b8df42dc1636d119675"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ad967e6cbdaa87b8df42dc1636d119675">duplicate</a> () const </td></tr>
<tr class="memitem:a45a2f0627c0214cfac74de0c28fb0b7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a45a2f0627c0214cfac74de0c28fb0b7c">duplicate</a> (int32_t newfd) const </td></tr>
<tr class="memitem:ab914af53fa7d8165ff05ce1b3649eff6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab914af53fa7d8165ff05ce1b3649eff6">useNonBlockingMode</a> () const </td></tr>
<tr class="memitem:ae3686bb24f4e1d57092479481efa3519"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ae3686bb24f4e1d57092479481efa3519">useBlockingMode</a> () const </td></tr>
<tr class="memitem:a63b969f0db8f0163a7586a66b112cf33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a63b969f0db8f0163a7586a66b112cf33">isUsingNonBlockingMode</a> () const </td></tr>
<tr class="memitem:abe28a94af94bce6122c606072da0cd04"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write</a> (uint16_t number) const </td></tr>
<tr class="memitem:a47a7e2def89d670256dc3a0df8a29391"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a47a7e2def89d670256dc3a0df8a29391">write</a> (uint32_t number) const </td></tr>
<tr class="memitem:a74daeedb23c083e536b8f75dc526bf75"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a74daeedb23c083e536b8f75dc526bf75">write</a> (uint64_t number) const </td></tr>
<tr class="memitem:ae88822c3260b2ee9213e7d17fa8d103b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ae88822c3260b2ee9213e7d17fa8d103b">write</a> (int16_t number) const </td></tr>
<tr class="memitem:a87b8575e395d4d28b4933f251fafa4f0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a87b8575e395d4d28b4933f251fafa4f0">write</a> (int32_t number) const </td></tr>
<tr class="memitem:aceeaa5027a4383b4e87063475e144c52"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aceeaa5027a4383b4e87063475e144c52">write</a> (int64_t number) const </td></tr>
<tr class="memitem:a1f764a75ac0c47bc8b9d85792c92e57b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a1f764a75ac0c47bc8b9d85792c92e57b">write</a> (float number) const </td></tr>
<tr class="memitem:a3098a6dffccde3117a38f9c94e421f64"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a3098a6dffccde3117a38f9c94e421f64">write</a> (double number) const </td></tr>
<tr class="memitem:a877787f3d7eed67798d8e8adc6e56507"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a877787f3d7eed67798d8e8adc6e56507">write</a> (unsigned char <a class="el" href="classcharacter.html">character</a>) const </td></tr>
<tr class="memitem:a84835e964733d718a316b89568da06a4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a84835e964733d718a316b89568da06a4">write</a> (char <a class="el" href="classcharacter.html">character</a>) const </td></tr>
<tr class="memitem:ab3503f5346ab56f79d3c3a9b24b33254"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab3503f5346ab56f79d3c3a9b24b33254">write</a> (bool value) const </td></tr>
<tr class="memitem:a6c7deae4623e5bc5075ffb52eb653757"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a6c7deae4623e5bc5075ffb52eb653757">write</a> (const unsigned char *string) const </td></tr>
<tr class="memitem:a4034d9728aeac0c8cb21666ff30b2eb4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a4034d9728aeac0c8cb21666ff30b2eb4">write</a> (const char *string) const </td></tr>
<tr class="memitem:a8fa40f30ef6d8a5645779e926e96aa1c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8fa40f30ef6d8a5645779e926e96aa1c">write</a> (const unsigned char *string, size_t size) const </td></tr>
<tr class="memitem:a09fe7090449a9115376cddb500f1bd39"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a09fe7090449a9115376cddb500f1bd39">write</a> (const char *string, size_t size) const </td></tr>
<tr class="memitem:a758b1955a7d9cb6b4d13068ee4f5ea8a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a758b1955a7d9cb6b4d13068ee4f5ea8a">write</a> (const void *buffer, size_t size) const </td></tr>
<tr class="memitem:a11683a8e0595ca705085528ff14bf40b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a11683a8e0595ca705085528ff14bf40b">write</a> (uint16_t number, long sec, long usec) const </td></tr>
<tr class="memitem:a2108bf1ca68bbe267aefecfa3b896626"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a2108bf1ca68bbe267aefecfa3b896626">write</a> (uint32_t number, long sec, long usec) const </td></tr>
<tr class="memitem:a8c3d3c675242592315720531ad199d79"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8c3d3c675242592315720531ad199d79">write</a> (uint64_t number, long sec, long usec) const </td></tr>
<tr class="memitem:a034c23b374e30a97fa0066a8414a59be"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a034c23b374e30a97fa0066a8414a59be">write</a> (int16_t number, long sec, long usec) const </td></tr>
<tr class="memitem:aeef0d4f4c1c186b33ffe6215a6b85abe"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aeef0d4f4c1c186b33ffe6215a6b85abe">write</a> (int32_t number, long sec, long usec) const </td></tr>
<tr class="memitem:a4e9431c142bcbace23bcdb5bb4b14106"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a4e9431c142bcbace23bcdb5bb4b14106">write</a> (int64_t number, long sec, long usec) const </td></tr>
<tr class="memitem:ab8c70ea0e99b2d6ef06dc4995dabe88d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab8c70ea0e99b2d6ef06dc4995dabe88d">write</a> (float number, long sec, long usec) const </td></tr>
<tr class="memitem:ab7291e95e311f3ccd3837f5ae7c720da"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab7291e95e311f3ccd3837f5ae7c720da">write</a> (double number, long sec, long usec) const </td></tr>
<tr class="memitem:ad36b61ffeed66474cd98d482af95240e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ad36b61ffeed66474cd98d482af95240e">write</a> (unsigned char <a class="el" href="classcharacter.html">character</a>, long sec, long usec) const </td></tr>
<tr class="memitem:a0762b08a4925a4d98b962e1b2a1d983e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a0762b08a4925a4d98b962e1b2a1d983e">write</a> (char <a class="el" href="classcharacter.html">character</a>, long sec, long usec) const </td></tr>
<tr class="memitem:ae06f2c59b9564a22531595ef3b743230"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ae06f2c59b9564a22531595ef3b743230">write</a> (bool value, long sec, long usec) const </td></tr>
<tr class="memitem:a328b4a4dbfa29e4c3f147502d4d31617"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a328b4a4dbfa29e4c3f147502d4d31617">write</a> (const unsigned char *string, long sec, long usec) const </td></tr>
<tr class="memitem:a2c5b9f12f68e62fe0421911a3853dbfb"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a2c5b9f12f68e62fe0421911a3853dbfb">write</a> (const char *string, long sec, long usec) const </td></tr>
<tr class="memitem:a5dc34ccb151a67d780805f11abe42303"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5dc34ccb151a67d780805f11abe42303">write</a> (const unsigned char *string, size_t size, long sec, long usec) const </td></tr>
<tr class="memitem:ad601f9a70dc2afdb5e2004c3f28f2631"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ad601f9a70dc2afdb5e2004c3f28f2631">write</a> (const char *string, size_t size, long sec, long usec) const </td></tr>
<tr class="memitem:a84dfe112236a36e786b73d55fa236819"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a84dfe112236a36e786b73d55fa236819">write</a> (const void *buffer, size_t size, long sec, long usec) const </td></tr>
<tr class="memitem:a4f399c8ae770baee23c6304004bb775a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a4f399c8ae770baee23c6304004bb775a">read</a> (uint16_t *buffer) const </td></tr>
<tr class="memitem:a04c45be7fa2669037cff6711b0f52b4d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a04c45be7fa2669037cff6711b0f52b4d">read</a> (uint32_t *buffer) const </td></tr>
<tr class="memitem:a3d2f0b37e530a4950ae45b90336d3176"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a3d2f0b37e530a4950ae45b90336d3176">read</a> (uint64_t *buffer) const </td></tr>
<tr class="memitem:a84ff77a17ff52d617eafd38725635a33"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a84ff77a17ff52d617eafd38725635a33">read</a> (int16_t *buffer) const </td></tr>
<tr class="memitem:a5bd562f5e88aab1dfba7a8ffea96cb8d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5bd562f5e88aab1dfba7a8ffea96cb8d">read</a> (int32_t *buffer) const </td></tr>
<tr class="memitem:afcc02d8a5532e596130f65ea3b0cf704"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#afcc02d8a5532e596130f65ea3b0cf704">read</a> (int64_t *buffer) const </td></tr>
<tr class="memitem:ad95961b66136fcc797f56828d1dd22b2"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ad95961b66136fcc797f56828d1dd22b2">read</a> (float *buffer) const </td></tr>
<tr class="memitem:af173405038fcefa4accb47010248bb95"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#af173405038fcefa4accb47010248bb95">read</a> (double *buffer) const </td></tr>
<tr class="memitem:a531d4b02fcc82637aae7e0d2a9cc1bf0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a531d4b02fcc82637aae7e0d2a9cc1bf0">read</a> (unsigned char *buffer) const </td></tr>
<tr class="memitem:a8e784547d25841042526b361454a6729"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8e784547d25841042526b361454a6729">read</a> (char *buffer) const </td></tr>
<tr class="memitem:a9df062aa04a0f0d544a28fb450d6e9dc"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a9df062aa04a0f0d544a28fb450d6e9dc">read</a> (bool *buffer) const </td></tr>
<tr class="memitem:acdec968957125b4d1f54814581e5dd5e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#acdec968957125b4d1f54814581e5dd5e">read</a> (unsigned char *buffer, size_t size) const </td></tr>
<tr class="memitem:af2161ebb155e4d4c6f5ab5e81bc02114"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#af2161ebb155e4d4c6f5ab5e81bc02114">read</a> (char *buffer, size_t size) const </td></tr>
<tr class="memitem:a6c6bbb2d0e1a1f1a0dc06725a36611e9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a6c6bbb2d0e1a1f1a0dc06725a36611e9">read</a> (void *buf, size_t size) const </td></tr>
<tr class="memitem:a3d405c72c5b6d5bc5d499b188eb99823"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a3d405c72c5b6d5bc5d499b188eb99823">read</a> (char **buffer, const char *terminator) const </td></tr>
<tr class="memitem:a295aee7dec1f2c2cd9050a408a605cff"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a295aee7dec1f2c2cd9050a408a605cff">read</a> (uint16_t *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:a6c56b9077959b324c23f0d000d6db72f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a6c56b9077959b324c23f0d000d6db72f">read</a> (uint32_t *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:a06148f2a82985b0a45de6c3fc0e64189"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a06148f2a82985b0a45de6c3fc0e64189">read</a> (uint64_t *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:a677bc9a351a13248566f0b5beb2bfd0d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a677bc9a351a13248566f0b5beb2bfd0d">read</a> (int16_t *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:a027bae5802237dac47a30026282cf6ef"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a027bae5802237dac47a30026282cf6ef">read</a> (int32_t *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:a69ffdeabd60ec4f4f7baf33b3244a1c0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a69ffdeabd60ec4f4f7baf33b3244a1c0">read</a> (int64_t *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:a74fd79eae196ae2270b73cf17c39c752"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a74fd79eae196ae2270b73cf17c39c752">read</a> (float *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:a7eedff6dbfd5db94fc5dd17183634c65"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7eedff6dbfd5db94fc5dd17183634c65">read</a> (double *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:aebb2face87bb84bf080b53712725cea1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aebb2face87bb84bf080b53712725cea1">read</a> (unsigned char *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:aebed5fb2a711f6bbe931f1fb59c23e5c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aebed5fb2a711f6bbe931f1fb59c23e5c">read</a> (char *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:a0eb7850eb24d699ef56ced7b754ae20a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a0eb7850eb24d699ef56ced7b754ae20a">read</a> (bool *buffer, long sec, long usec) const </td></tr>
<tr class="memitem:a6ef6013b7193fd44e960ecf79cf285f1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a6ef6013b7193fd44e960ecf79cf285f1">read</a> (unsigned char *buffer, size_t size, long sec, long usec) const </td></tr>
<tr class="memitem:ac84f7a2f3eebea8d7ae35f4ebc03a171"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac84f7a2f3eebea8d7ae35f4ebc03a171">read</a> (char *buffer, size_t size, long sec, long usec) const </td></tr>
<tr class="memitem:a8af0f6c118ddd02407e7134b6016db39"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8af0f6c118ddd02407e7134b6016db39">read</a> (void *buf, size_t size, long sec, long usec) const </td></tr>
<tr class="memitem:ae8dcc47d6a473241edee77ab620c4d9d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ae8dcc47d6a473241edee77ab620c4d9d">read</a> (char **buffer, const char *terminator, long sec, long usec) const </td></tr>
<tr class="memitem:a5257a5de8f9e508664ba390ab434994e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5257a5de8f9e508664ba390ab434994e">waitForNonBlockingRead</a> (long sec, long usec) const </td></tr>
<tr class="memitem:a5a7e6820a2a3288b0889b7314935f6cd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5a7e6820a2a3288b0889b7314935f6cd">waitForNonBlockingWrite</a> (long sec, long usec) const </td></tr>
<tr class="memitem:a873da850bf73716babe080f7fa723784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a873da850bf73716babe080f7fa723784">retryInterruptedReads</a> ()</td></tr>
<tr class="memitem:a7f7311c4fa746bcf1f75f076264c308b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7f7311c4fa746bcf1f75f076264c308b">dontRetryInterruptedReads</a> ()</td></tr>
<tr class="memitem:ac372c3c60abd093ea7a0b70c74e30f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac372c3c60abd093ea7a0b70c74e30f9b">retryInterruptedWrites</a> ()</td></tr>
<tr class="memitem:ac70cc7d8e024f7bb6bf8fc926067d9ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac70cc7d8e024f7bb6bf8fc926067d9ba">dontRetryInterruptedWrites</a> ()</td></tr>
<tr class="memitem:ae6f560f93d4b1ee57a7332b19588d3af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ae6f560f93d4b1ee57a7332b19588d3af">retryInterruptedWaits</a> ()</td></tr>
<tr class="memitem:a879e0146d88f66e6188442e8b4b1cb8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a879e0146d88f66e6188442e8b4b1cb8b">dontRetryInterruptedWaits</a> ()</td></tr>
<tr class="memitem:aced1588c0b772a96548b8b1a737199c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aced1588c0b772a96548b8b1a737199c2">retryInterruptedFcntl</a> ()</td></tr>
<tr class="memitem:a32dd611bf1ab97bfff2c14535a403f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a32dd611bf1ab97bfff2c14535a403f74">dontRetryInterruptedFcntl</a> ()</td></tr>
<tr class="memitem:a08e322411718595166970dc371981457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a08e322411718595166970dc371981457">retryInterruptedIoctl</a> ()</td></tr>
<tr class="memitem:a50e1255f92ef1f93396a2badabe8998b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a50e1255f92ef1f93396a2badabe8998b">dontRetryInterruptedIoctl</a> ()</td></tr>
<tr class="memitem:a8385bed0f0586feb7129ffa3ce5e5c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a8385bed0f0586feb7129ffa3ce5e5c55">allowShortReads</a> ()</td></tr>
<tr class="memitem:a450567c8744e8162832cfc325051ee6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a450567c8744e8162832cfc325051ee6e">dontAllowShortReads</a> ()</td></tr>
<tr class="memitem:abe7c22612b0dd31718fac688d896b084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abe7c22612b0dd31718fac688d896b084">allowShortWrites</a> ()</td></tr>
<tr class="memitem:a5585ce27c88d29da92e37aa23f027e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5585ce27c88d29da92e37aa23f027e1b">dontAllowShortWrites</a> ()</td></tr>
<tr class="memitem:aca29365b7120c0030a7e883e58913817"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener</a> (<a class="el" href="classlistener.html">listener</a> *lstnr)</td></tr>
<tr class="memitem:a412b125e78b8c6f6c28c960b102e7254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a412b125e78b8c6f6c28c960b102e7254">dontUseListener</a> ()</td></tr>
<tr class="memitem:ac03b7f3d7115ae2e02c7a1383e072a9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlistener.html">listener</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac03b7f3d7115ae2e02c7a1383e072a9b">getListener</a> ()</td></tr>
<tr class="memitem:a94f748949fb05e34fd2db8a233d38a64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a94f748949fb05e34fd2db8a233d38a64">useListenerInsideReads</a> ()</td></tr>
<tr class="memitem:abffb81cce26885c6a7f3fc8c3cd6614e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abffb81cce26885c6a7f3fc8c3cd6614e">dontUseListenerInsideReads</a> ()</td></tr>
<tr class="memitem:aeb820d6a05a0dd62c60f75b4b5b3482d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aeb820d6a05a0dd62c60f75b4b5b3482d">useListenerInsideWrites</a> ()</td></tr>
<tr class="memitem:aa0d2af6177c3e535643f05f51543e7b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aa0d2af6177c3e535643f05f51543e7b5">dontUseListenerInsideWrites</a> ()</td></tr>
<tr class="memitem:a2c8b2e0a43b365a91abcde45de4beadf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a2c8b2e0a43b365a91abcde45de4beadf">passFileDescriptor</a> (int32_t fd) const </td></tr>
<tr class="memitem:ac3a7c0944085537908fb682b02bd0b26"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac3a7c0944085537908fb682b02bd0b26">receiveFileDescriptor</a> (int32_t *fd) const </td></tr>
<tr class="memitem:a50c42991f500b7fc1ef01fcdf0f240fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a50c42991f500b7fc1ef01fcdf0f240fd">translateByteOrder</a> ()</td></tr>
<tr class="memitem:a5a2ea19fa8e4d360f969f0446a556f2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5a2ea19fa8e4d360f969f0446a556f2a">dontTranslateByteOrder</a> ()</td></tr>
<tr class="memitem:a623db8e88ea40bb2d2a0199dcbb13836"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a623db8e88ea40bb2d2a0199dcbb13836">fCntl</a> (int32_t command, long arg) const </td></tr>
<tr class="memitem:a1873274bb17f37c464cce7166c24dd51"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a1873274bb17f37c464cce7166c24dd51">ioCtl</a> (int32_t command, void *arg) const </td></tr>
<tr class="memitem:a68d4f98f00a3794e44bafb8c94f7b906"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a68d4f98f00a3794e44bafb8c94f7b906">useNaglesAlgorithm</a> ()</td></tr>
<tr class="memitem:a40cd844190971abebd6af838f1b2becb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a40cd844190971abebd6af838f1b2becb">dontUseNaglesAlgorithm</a> ()</td></tr>
<tr class="memitem:a92e149613647efa0e87963f07479e7d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a92e149613647efa0e87963f07479e7d9">setTcpWriteBufferSize</a> (int32_t size)</td></tr>
<tr class="memitem:a65c6293f0c320922e46d4662e5d2e85f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a65c6293f0c320922e46d4662e5d2e85f">getTcpWriteBufferSize</a> (int32_t *size)</td></tr>
<tr class="memitem:a7cd820738744ec4723be54351b026339"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7cd820738744ec4723be54351b026339">setTcpReadBufferSize</a> (int32_t size)</td></tr>
<tr class="memitem:a5bf0a1af7a070fe41262d39d0ec23281"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a5bf0a1af7a070fe41262d39d0ec23281">getTcpReadBufferSize</a> (int32_t *size)</td></tr>
<tr class="memitem:a0f2e40bd232c70c7a6dae2ab01ddbba0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a0f2e40bd232c70c7a6dae2ab01ddbba0">getType</a> () const </td></tr>
<tr class="memitem:ac0589e7427841901e23c840124cc3e69"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ac0589e7427841901e23c840124cc3e69">getPeerAddress</a> () const </td></tr>
<tr class="memitem:a7d62107de57c6670c508571d43b4b21f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a7d62107de57c6670c508571d43b4b21f">setWriteBufferSize</a> (ssize_t size) const </td></tr>
<tr class="memitem:a962ac41ec4a8d26aeb10b34b76d94f5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a962ac41ec4a8d26aeb10b34b76d94f5b">flushWriteBuffer</a> (long sec, long usec) const </td></tr>
<tr class="memitem:a074c400e8cfb189433b98848a18ae061"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a074c400e8cfb189433b98848a18ae061">setReadBufferSize</a> (ssize_t size) const </td></tr>
<tr class="memitem:aa8620a165895ff4e8a433e4539c10955"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#aa8620a165895ff4e8a433e4539c10955">closeOnExec</a> ()</td></tr>
<tr class="memitem:a72033e31c0cbe18602b9a21e9493b590"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a72033e31c0cbe18602b9a21e9493b590">dontCloseOnExec</a> ()</td></tr>
<tr class="memitem:a2d3f857b7f6ee423a39640c5dc2ebfee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a2d3f857b7f6ee423a39640c5dc2ebfee">getCloseOnExec</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a015c15b53476f7741d4693481a0b2a96"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a015c15b53476f7741d4693481a0b2a96">hostToNet</a> (uint16_t value)</td></tr>
<tr class="memitem:ab0dd118e7f10d87de4300ac399bd1272"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#ab0dd118e7f10d87de4300ac399bd1272">hostToNet</a> (uint32_t value)</td></tr>
<tr class="memitem:a231c459ea091720cb70b7b1b071fc132"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a231c459ea091720cb70b7b1b071fc132">hostToNet</a> (uint64_t value)</td></tr>
<tr class="memitem:a687405f4614390bb3bf6ad91ea0a709a"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a687405f4614390bb3bf6ad91ea0a709a">netToHost</a> (uint16_t value)</td></tr>
<tr class="memitem:a04f43ceb482795d7a26631ba836fe9d3"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#a04f43ceb482795d7a26631ba836fe9d3">netToHost</a> (uint32_t value)</td></tr>
<tr class="memitem:abf96fd9d695c8bc46a8d6a73d620c7b8"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfiledescriptor.html#abf96fd9d695c8bc46a8d6a73d620c7b8">netToHost</a> (uint64_t value)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The filedescriptor class is a base class for other classes that utilize file descriptors. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0179c81bbcb0c39bfe822a8b4f726a32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">filedescriptor::filedescriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an instance of the filedescriptor class. </p>

</div>
</div>
<a class="anchor" id="a8a55f4c684b0151d0088018d8dcc0267"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">filedescriptor::filedescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfiledescriptor.html">filedescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an instance of the filedescriptor class that is a copy of "f". </p>

</div>
</div>
<a class="anchor" id="ade7e2d6dd54324862720e600c3342b89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual filedescriptor::~filedescriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this instance of the filedescriptor class. Calls <a class="el" href="classfiledescriptor.html#a67442522f75c98d34ce5778ab5eeb754">close()</a> if it hasn't already been called. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a8385bed0f0586feb7129ffa3ce5e5c55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::allowShortReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, <a class="el" href="classfiledescriptor.html#a4f399c8ae770baee23c6304004bb775a">read()</a> will attempt to read the specified number of bytes from the file descriptor, even if several passes are necessary.</p>
<p>This method causes a <a class="el" href="classfiledescriptor.html#a4f399c8ae770baee23c6304004bb775a">read()</a> to attempt only a single pass and return the number of bytes that were read during that pass whether the specified number of bytes were read or not.</p>
<p>Note that reads longer than SSIZE_MAX will only attempt to read SSIZE_MAX bytes. </p>

</div>
</div>
<a class="anchor" id="abe7c22612b0dd31718fac688d896b084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::allowShortWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> will attempt to write the specified number of bytes from the file descriptor, in several passes if necessary.</p>
<p>This method causes a <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> to attempt only a single pass and return the number of bytes that were written during that pass whether the specified number of bytes were written or not.</p>
<p>Note that writes longer than SSIZE_MAX will only attempt to write SSIZE_MAX bytes. </p>

</div>
</div>
<a class="anchor" id="a67442522f75c98d34ce5778ab5eeb754"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool filedescriptor::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Closes the file descriptor. Returns true on success and false on failure. </p>

<p>Reimplemented in <a class="el" href="classmodemserver.html#aa101470691771ea8935cff08a07062ec">modemserver</a>, and <a class="el" href="classmodemclient.html#a59da1ccad2a46ae4b49eb7190b95d955">modemclient</a>.</p>

</div>
</div>
<a class="anchor" id="aa8620a165895ff4e8a433e4539c10955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::closeOnExec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the close-on-exec status is false (the default), then the file descriptor will remain open across an execve() call, otherwise it will be closed.</p>
<p>This method sets the close-on-exec status to true. </p>

</div>
</div>
<a class="anchor" id="a450567c8744e8162832cfc325051ee6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontAllowShortReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, <a class="el" href="classfiledescriptor.html#a4f399c8ae770baee23c6304004bb775a">read()</a> will attempt to read the specified number of bytes from the file descriptor, even if several passes are necessary.</p>
<p>This method causes that default behavior to be observed. </p>

</div>
</div>
<a class="anchor" id="a5585ce27c88d29da92e37aa23f027e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontAllowShortWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> will attempt to write the specified number of bytes from the file descriptor, even if several passes are necessary.</p>
<p>This method causes that default behavior to be observed. </p>

</div>
</div>
<a class="anchor" id="a72033e31c0cbe18602b9a21e9493b590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::dontCloseOnExec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the close-on-exec status is false (the default), then the file descriptor will remain open across an execve() call, otherwise it will be closed.</p>
<p>This method sets the close-on-exec status to false (the default). </p>

</div>
</div>
<a class="anchor" id="a32dd611bf1ab97bfff2c14535a403f74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontRetryInterruptedFcntl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes fcntl operations not to be automatically retried if interrupted by a signal. If this is set, a fcntl is occurring and a signal interrupts it, the fcntl fails, the system error is set to EINTR and the fcntl must be retried. </p>

</div>
</div>
<a class="anchor" id="a50e1255f92ef1f93396a2badabe8998b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontRetryInterruptedIoctl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes ioctl operations not to be automatically retried if interrupted by a signal. If this is set, a ioctl is occurring and a signal interrupts it, the ioctl fails, the system error is set to EINTR and the ioctl must be retried. </p>

</div>
</div>
<a class="anchor" id="a7f7311c4fa746bcf1f75f076264c308b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontRetryInterruptedReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes reads not to automatically retry if interrupted by a signal. This is the default behavior. By default, if a read is occurring and a signal interrupts it, the read fails, the system error is set to EINTR and the read must be retried. </p>

</div>
</div>
<a class="anchor" id="a879e0146d88f66e6188442e8b4b1cb8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontRetryInterruptedWaits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes wait operations not to be automatically retried if interrupted by a signal. If this is set, a wait is occurring and a signal interrupts it, the wait fails, the system error is set to EINTR and the wait must be retried. </p>

</div>
</div>
<a class="anchor" id="ac70cc7d8e024f7bb6bf8fc926067d9ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontRetryInterruptedWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes writes not to automatically retry if interrupted by a signal. This is the default behavior. By default, if a write is occurring and a signal interrupts it, the write fails, the system error is set to EINTR and the write must be retried. </p>

</div>
</div>
<a class="anchor" id="a5a2ea19fa8e4d360f969f0446a556f2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontTranslateByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Don't translate integers from native byte order to network byte order during writes and vice-versa during reads. This is the default behavior. </p>

</div>
</div>
<a class="anchor" id="a412b125e78b8c6f6c28c960b102e7254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontUseListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, calls to <a class="el" href="classfiledescriptor.html#a5257a5de8f9e508664ba390ab434994e">waitForNonBlockingRead()</a> and <a class="el" href="classfiledescriptor.html#a5a7e6820a2a3288b0889b7314935f6cd">waitForNonBlockingWrite()</a> will wait using the select() system call or similar.</p>
<p>This method causes the default behavior to be observed, even if <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a> was called previously. </p>

</div>
</div>
<a class="anchor" id="abffb81cce26885c6a7f3fc8c3cd6614e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontUseListenerInsideReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the listener set by a call to <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a> not to be used internally by the <a class="el" href="classfiledescriptor.html#a4f399c8ae770baee23c6304004bb775a">read()</a> methods. See <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a>. </p>

</div>
</div>
<a class="anchor" id="aa0d2af6177c3e535643f05f51543e7b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::dontUseListenerInsideWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the listener set by a call to <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a> not to be used internally by the <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> methods. See <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a>. </p>

</div>
</div>
<a class="anchor" id="a40cd844190971abebd6af838f1b2becb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::dontUseNaglesAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes all <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a>'s to be sent immediately. (disables Nagle's algorithm)</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="ad967e6cbdaa87b8df42dc1636d119675"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t filedescriptor::duplicate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Duplicates the file descriptor and returns the handle of the duplicate descriptor. The old and new descriptors may be used interchangeably, they share locks, position pointers, flags (except the close-on-exec flag), etc.</p>
<p>Returns the lowest-numbered unused descriptor on success or -1 on failure. </p>

</div>
</div>
<a class="anchor" id="a45a2f0627c0214cfac74de0c28fb0b7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::duplicate </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>newfd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets file descriptor handle "newfd" to be a duplicate of this file descriptor. If "newfd" is already open, it will be closed first.</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a623db8e88ea40bb2d2a0199dcbb13836"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t filedescriptor::fCntl </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the fcntl() system call to perform various low-level file descriptor operations. </p>

</div>
</div>
<a class="anchor" id="a962ac41ec4a8d26aeb10b34b76d94f5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::flushWriteBuffer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If an application does many small writes, the overhead of all of those system calls can slow the application down substantially. To address that issue, the filedescriptor class can buffer data passed in to any of it's <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> methods and only make system calls when the buffer is full or when it's flushed manually. Note that when using buffered writes, no data is actually written to the file descriptor until the buffer is full or until it's flushed manually.</p>
<p>Do not confuse this buffer with the tcp write buffer. The tcp write buffer resides in kernel space, is populated by the <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> system call in an analagous manner and is used to minimize network latency, not application latency due to system calls. This buffer is in user space and populated prior to the <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> system call.</p>
<p>This method causes the contents of the write buffer to be written to the filedescriptor immediately.</p>
<p>Returns true on success and false on failure.</p>
<p>If the buffer cannot be flushed within "sec" seconds and "usec" microseconds, then the method will fail. Set either "sec" or "usec" to -1 to disable the timeout and allow the method to block until the buffer has been flushed. </p>

</div>
</div>
<a class="anchor" id="a2d3f857b7f6ee423a39640c5dc2ebfee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::getCloseOnExec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the close-on-exec status is false (the default), then the file descriptor will remain open across an execve() call, otherwise it will be closed.</p>
<p>This method returns true if the close-on-exec status is set to true and false otherwise. </p>

</div>
</div>
<a class="anchor" id="aedff2b95cfac65447dac45b35539387f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t filedescriptor::getFileDescriptor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the file descriptor. </p>

</div>
</div>
<a class="anchor" id="ac03b7f3d7115ae2e02c7a1383e072a9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlistener.html">listener</a>* filedescriptor::getListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the listener set previously by <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a> or NULL if none has been set. </p>

</div>
</div>
<a class="anchor" id="ac0589e7427841901e23c840124cc3e69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* filedescriptor::getPeerAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the IP address of the client at the other end of the connection if the filedescriptor is an inet socket or NULL otherwise.</p>
<p>Note that the buffer for the address is allocated internally and must be freed by the calling program. </p>

</div>
</div>
<a class="anchor" id="a5bf0a1af7a070fe41262d39d0ec23281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::getTcpReadBufferSize </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the size of the kernel's TCP read buffer (in bytes) into buffer "size". This is only useful for TCP socket file descriptors. Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a65c6293f0c320922e46d4662e5d2e85f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::getTcpWriteBufferSize </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the size of the kernel's TCP write buffer (in bytes) into buffer "size". This is only useful for TCP socket file descriptors. Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a0f2e40bd232c70c7a6dae2ab01ddbba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* filedescriptor::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string representing the type of the filedescriptor. This is "filedescriptor" by default but a child class may override this method and return something else. </p>

</div>
</div>
<a class="anchor" id="a015c15b53476f7741d4693481a0b2a96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t filedescriptor::hostToNet </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 16-bit integer from host byte order to network byte order. </p>

</div>
</div>
<a class="anchor" id="ab0dd118e7f10d87de4300ac399bd1272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t filedescriptor::hostToNet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 32-bit integer from host byte order to network byte order. </p>

</div>
</div>
<a class="anchor" id="a231c459ea091720cb70b7b1b071fc132"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t filedescriptor::hostToNet </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 64-bit integer from host byte order to network byte order. </p>

</div>
</div>
<a class="anchor" id="a1873274bb17f37c464cce7166c24dd51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t filedescriptor::ioCtl </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the ioctl() system call to perform various low-level file descriptor operations. </p>

</div>
</div>
<a class="anchor" id="a63b969f0db8f0163a7586a66b112cf33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::isUsingNonBlockingMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the file descriptor is in non-blocking mode and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a687405f4614390bb3bf6ad91ea0a709a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t filedescriptor::netToHost </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 16-bit integer from network byte order to host byte order. </p>

</div>
</div>
<a class="anchor" id="a04f43ceb482795d7a26631ba836fe9d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t filedescriptor::netToHost </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 32-bit integer from network byte order to host byte order. </p>

</div>
</div>
<a class="anchor" id="abf96fd9d695c8bc46a8d6a73d620c7b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t filedescriptor::netToHost </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an unsigned 64-bit integer from network byte order to host byte order. </p>

</div>
</div>
<a class="anchor" id="a337e115dbf9075d2e06890cb85d09e2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfiledescriptor.html">filedescriptor</a>&amp; filedescriptor::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfiledescriptor.html">filedescriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes this instance of the filedescriptor class identical to "f". </p>

</div>
</div>
<a class="anchor" id="a2c8b2e0a43b365a91abcde45de4beadf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool filedescriptor::passFileDescriptor </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sends file descriptor "fd" to the file descriptor. This is useful for passing an open file descriptor from one process to another over a unix socket, for example. </p>

</div>
</div>
<a class="anchor" id="a4f399c8ae770baee23c6304004bb775a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 16-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a04c45be7fa2669037cff6711b0f52b4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 32-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a3d2f0b37e530a4950ae45b90336d3176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 64-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a84ff77a17ff52d617eafd38725635a33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 16-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a5bd562f5e88aab1dfba7a8ffea96cb8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 32-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="afcc02d8a5532e596130f65ea3b0cf704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit integer from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="ad95961b66136fcc797f56828d1dd22b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a floating point number from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="af173405038fcefa4accb47010248bb95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a double-precision floating point number from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a531d4b02fcc82637aae7e0d2a9cc1bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned character from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a8e784547d25841042526b361454a6729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an character from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a9df062aa04a0f0d544a28fb450d6e9dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a boolean value from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="acdec968957125b4d1f54814581e5dd5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" unsigned characters from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="af2161ebb155e4d4c6f5ab5e81bc02114"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" characters from the file descriptor into "buffer". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a6c6bbb2d0e1a1f1a0dc06725a36611e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" bytes from the file descriptor into "buf". Returns the number of bytes that were successfully read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a3d405c72c5b6d5bc5d499b188eb99823"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads from the file desciptor into "buffer" until "terminator" is encountered.</p>
<p>Note that "buffer" is allocated internally and must be freed by the calling program.</p>
<p>Returns the number of bytes that were read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a295aee7dec1f2c2cd9050a408a605cff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 16-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a6c56b9077959b324c23f0d000d6db72f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 32-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a06148f2a82985b0a45de6c3fc0e64189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned 64-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a677bc9a351a13248566f0b5beb2bfd0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 16-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a027bae5802237dac47a30026282cf6ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 32-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a69ffdeabd60ec4f4f7baf33b3244a1c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit integer from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a74fd79eae196ae2270b73cf17c39c752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a floating point number from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a7eedff6dbfd5db94fc5dd17183634c65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a double-precision floating point number from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="aebb2face87bb84bf080b53712725cea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned character from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="aebed5fb2a711f6bbe931f1fb59c23e5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a character from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a0eb7850eb24d699ef56ced7b754ae20a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a boolean value from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a6ef6013b7193fd44e960ecf79cf285f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" unsigned characters from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="ac84f7a2f3eebea8d7ae35f4ebc03a171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" characters from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a8af0f6c118ddd02407e7134b6016db39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads "size" bytes from the file descriptor into "buffer" with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully read, RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="ae8dcc47d6a473241edee77ab620c4d9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::read </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>terminator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads from the file desciptor into "buffer" until "terminator" is encountered with a timeout of "sec" seconds and "usec" microseconds.</p>
<p>Note that "buffer" is allocated internally and must be freed by the calling program.</p>
<p>Returns the number of bytes that were read or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="ac3a7c0944085537908fb682b02bd0b26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool filedescriptor::receiveFileDescriptor </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Receives a file descriptor into buffer "fd". This is useful for receiving an open file descriptor passed from another process over a unix socket, for example. </p>

</div>
</div>
<a class="anchor" id="aced1588c0b772a96548b8b1a737199c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::retryInterruptedFcntl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes fcntl operations to be automatically retried if interrupted by a signal. This is the default behavior. Otherwise, if a fcntl is occurring and a signal interrupts it, the fcntl fails, the system error is set to EINTR and the fcntl must be retried. </p>

</div>
</div>
<a class="anchor" id="a08e322411718595166970dc371981457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::retryInterruptedIoctl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes ioctl operations to be automatically retried if interrupted by a signal. This is the default behavior. Otherwise, if a ioctl is occurring and a signal interrupts it, the ioctl fails, the system error is set to EINTR and the ioctl must be retried. </p>

</div>
</div>
<a class="anchor" id="a873da850bf73716babe080f7fa723784"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::retryInterruptedReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes reads to automatically retry if interrupted by a signal. By default, if a read is occurring and a signal interrupts it, the read fails, the system error is set to EINTR and the read must be retried. </p>

</div>
</div>
<a class="anchor" id="ae6f560f93d4b1ee57a7332b19588d3af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::retryInterruptedWaits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes wait operations to be automatically retried if interrupted by a signal. This is the default behavior. Otherwise, if a wait is occurring and a signal interrupts it, the wait fails, the system error is set to EINTR and the wait must be retried. </p>

</div>
</div>
<a class="anchor" id="ac372c3c60abd093ea7a0b70c74e30f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::retryInterruptedWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes writes to automatically retry if interrupted by a signal. By default, if a write is occurring and a signal interrupts it, the write fails, the system error is set to EINTR and the write must be retried. </p>

</div>
</div>
<a class="anchor" id="a5e38ff382e70ed0993fcb087aae86ca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::setFileDescriptor </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>filedesc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the file descriptor associated with the class to "filedesc". </p>

</div>
</div>
<a class="anchor" id="a074c400e8cfb189433b98848a18ae061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::setReadBufferSize </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If an application does many small reads, the overhead of all of those system calls can slow the application down substantially. To address that issue, the filedescriptor class can create a read buffer and attempt to keep it full. When the first read is attempted, it will attempt to read "size" bytes into the buffer and only return the number of bytes specified in the read. Subsequent reads will just return data from the buffer without doing additional system calls unless the buffer is empty.</p>
<p>Do not confuse this buffer with the tcp read buffer. The tcp read buffer resides in kernel space, is populated by the <a class="el" href="classfiledescriptor.html#a4f399c8ae770baee23c6304004bb775a">read()</a> system call in an analagous manner and is used to minimize network latency, not application latency due to system calls. This buffer is in user space and populated in the manner described above.</p>
<p>This method sets the read buffer size to "size" bytes and returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a7cd820738744ec4723be54351b026339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::setTcpReadBufferSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the size of the kernel's TCP read buffer to "size" bytes. This is only useful for TCP socket file descriptors. Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a92e149613647efa0e87963f07479e7d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::setTcpWriteBufferSize </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the size of the kernel's TCP write buffer to "size" bytes. This is only useful for TCP socket file descriptors. Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a7d62107de57c6670c508571d43b4b21f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::setWriteBufferSize </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If an application does many small writes, the overhead of all of those system calls can slow the application down substantially. To address that issue, the filedescriptor class can buffer data passed in to any of it's <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> methods and only make system calls when the buffer is full or when it's flushed manually. Note that when using buffered writes, no data is actually written to the file descriptor until the buffer is full or until it's flushed manually.</p>
<p>Do not confuse this buffer with the tcp write buffer. The tcp write buffer resides in kernel space, is populated by the <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> system call and is used to minimize network latency, not application latency due to system calls. This buffer is in user space and populated prior to the <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> system call.</p>
<p>This method sets the write buffer size to "size" bytes. A size of 0 means not to buffer writes at all.</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="a50c42991f500b7fc1ef01fcdf0f240fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::translateByteOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate integers from native byte order to network byte order during writes and vice-versa during reads. By default, no translation is done. </p>

</div>
</div>
<a class="anchor" id="ae3686bb24f4e1d57092479481efa3519"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool filedescriptor::useBlockingMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts the file descriptor in blocking mode. Returns true on success and false on failure. </p>

<p>Reimplemented in <a class="el" href="classserversocket.html#a8e17be24af0dc3dc0fb3162bfed8b895">serversocket</a>, and <a class="el" href="classclientsocket.html#a9c72de1d86b9b0a31f2cafd7e1499ded">clientsocket</a>.</p>

</div>
</div>
<a class="anchor" id="aca29365b7120c0030a7e883e58913817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::useListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlistener.html">listener</a> *&#160;</td>
          <td class="paramname"><em>lstnr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By default, calls to <a class="el" href="classfiledescriptor.html#a5257a5de8f9e508664ba390ab434994e">waitForNonBlockingRead()</a> and <a class="el" href="classfiledescriptor.html#a5a7e6820a2a3288b0889b7314935f6cd">waitForNonBlockingWrite()</a> will wait using the select() system call or similar.</p>
<p>This method causes calls to <a class="el" href="classfiledescriptor.html#a5257a5de8f9e508664ba390ab434994e">waitForNonBlockingRead()</a> and <a class="el" href="classfiledescriptor.html#a5a7e6820a2a3288b0889b7314935f6cd">waitForNonBlockingWrite()</a> to in turn call lstnr-&gt;<a class="el" href="classfiledescriptor.html#a5257a5de8f9e508664ba390ab434994e">waitForNonBlockingRead()</a> or lstnr-&gt;<a class="el" href="classfiledescriptor.html#a5a7e6820a2a3288b0889b7314935f6cd">waitForNonBlockingWrite()</a> rather than using select() directly. </p>

</div>
</div>
<a class="anchor" id="a94f748949fb05e34fd2db8a233d38a64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::useListenerInsideReads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the listener set by a call to <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a> to be used internally by the <a class="el" href="classfiledescriptor.html#a4f399c8ae770baee23c6304004bb775a">read()</a> methods. See <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a>. </p>

</div>
</div>
<a class="anchor" id="aeb820d6a05a0dd62c60f75b4b5b3482d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filedescriptor::useListenerInsideWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the listener set by a call to <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a> to be be used internally by the <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> methods. See <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a>. </p>

</div>
</div>
<a class="anchor" id="a68d4f98f00a3794e44bafb8c94f7b906"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool filedescriptor::useNaglesAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes small <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a>'s to be collected up and sent together when either the kernel's write buffer is full or when a maximum of 0.2 seconds has gone by. (enable Nagle's algorithm)</p>
<p>This is the default.</p>
<p>Returns true on success and false on failure. </p>

</div>
</div>
<a class="anchor" id="ab914af53fa7d8165ff05ce1b3649eff6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool filedescriptor::useNonBlockingMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Puts the file descriptor in non-blocking mode. Returns true on success and false on failure. </p>

<p>Reimplemented in <a class="el" href="classserversocket.html#a70996bcae7c14f1024d512b42cefa249">serversocket</a>, and <a class="el" href="classclientsocket.html#a63864088d5d3adb75e9604438f7ff63d">clientsocket</a>.</p>

</div>
</div>
<a class="anchor" id="a5257a5de8f9e508664ba390ab434994e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t filedescriptor::waitForNonBlockingRead </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the application to wait until a <a class="el" href="classfiledescriptor.html#a4f399c8ae770baee23c6304004bb775a">read()</a> will proceed without blocking or until "sec" seconds and "usec" microseconds have elapsed.</p>
<p>Entering -1 for either parameter causes the method to wait indefinitely.</p>
<p>Entering 0 for both parameters causes the method to fall through immediately unless a data is immediately available.</p>
<p>Returns RESULT_ERROR on error, RESULT_TIMEOUT on timeout and otherwise returns the number of file descriptors that are ready to be read from.</p>
<p>This will usually be 1, indicating that the file descriptor represented by the class is ready to be read from. However, if <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a> has been called, it may be greater than 1, indicating that a set of file descriptors that the listener is listening on are all ready to be read from. </p>

</div>
</div>
<a class="anchor" id="a5a7e6820a2a3288b0889b7314935f6cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t filedescriptor::waitForNonBlockingWrite </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the application to wait until a <a class="el" href="classfiledescriptor.html#abe28a94af94bce6122c606072da0cd04">write()</a> will proceed without blocking or until "sec" seconds and "usec" microseconds have elapsed.</p>
<p>Entering -1 for either parameter causes the method to wait indefinitely.</p>
<p>Entering 0 for both parameters causes the method to fall through immediately unless a data is immediately available.</p>
<p>Returns RESULT_ERROR on error, RESULT_TIMEOUT on timeout and otherwise returns the number of file descriptors that are ready to be written to.</p>
<p>This will usually be 1, indicating that the file descriptor represented by the class is ready to be written to. However, if <a class="el" href="classfiledescriptor.html#aca29365b7120c0030a7e883e58913817">useListener()</a> has been called, it may be greater than 1, indicating that a set of file descriptors that the listener is listening on are all ready to be written to. </p>

</div>
</div>
<a class="anchor" id="abe28a94af94bce6122c606072da0cd04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a47a7e2def89d670256dc3a0df8a29391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a74daeedb23c083e536b8f75dc526bf75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="ae88822c3260b2ee9213e7d17fa8d103b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a87b8575e395d4d28b4933f251fafa4f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="aceeaa5027a4383b4e87063475e144c52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a1f764a75ac0c47bc8b9d85792c92e57b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a3098a6dffccde3117a38f9c94e421f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a877787f3d7eed67798d8e8adc6e56507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "character" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a84835e964733d718a316b89568da06a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "character" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="ab3503f5346ab56f79d3c3a9b24b33254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "value" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a6c7deae4623e5bc5075ffb52eb653757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes NULL-terminated "string" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a4034d9728aeac0c8cb21666ff30b2eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes NULL-terminated "string" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a8fa40f30ef6d8a5645779e926e96aa1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "string" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. Note that it is possible to write beyond the string's NULL terminator using this method. </p>

</div>
</div>
<a class="anchor" id="a09fe7090449a9115376cddb500f1bd39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "string" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. Note that it is possible to write beyond the string's NULL terminator using this method. </p>

</div>
</div>
<a class="anchor" id="a758b1955a7d9cb6b4d13068ee4f5ea8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "buffer" to the file descriptor. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred. </p>

</div>
</div>
<a class="anchor" id="a11683a8e0595ca705085528ff14bf40b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a2108bf1ca68bbe267aefecfa3b896626"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a8c3d3c675242592315720531ad199d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a034c23b374e30a97fa0066a8414a59be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="aeef0d4f4c1c186b33ffe6215a6b85abe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a4e9431c142bcbace23bcdb5bb4b14106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="ab8c70ea0e99b2d6ef06dc4995dabe88d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="ab7291e95e311f3ccd3837f5ae7c720da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "number" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="ad36b61ffeed66474cd98d482af95240e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "character" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a0762b08a4925a4d98b962e1b2a1d983e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "character" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="ae06f2c59b9564a22531595ef3b743230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "value" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a328b4a4dbfa29e4c3f147502d4d31617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes NULL-terminated "string" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a2c5b9f12f68e62fe0421911a3853dbfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes NULL-terminated "string" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
<a class="anchor" id="a5dc34ccb151a67d780805f11abe42303"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "string" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. Note that it is possible to write beyond the string's NULL terminator using this method. </p>

</div>
</div>
<a class="anchor" id="ad601f9a70dc2afdb5e2004c3f28f2631"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "string" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. Note that it is possible to write beyond the string's NULL terminator using this method. </p>

</div>
</div>
<a class="anchor" id="a84dfe112236a36e786b73d55fa236819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t filedescriptor::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>usec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes "size" bytes of "buffer" to the file descriptor with a timeout of "sec" seconds and "usec" microseconds. Returns the number of bytes that were successfully written or RESULT_ERROR if an error occurred or RESULT_TIMEOUT if a timeout occurred. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 1 2012 18:51:48 for Rudiments by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
