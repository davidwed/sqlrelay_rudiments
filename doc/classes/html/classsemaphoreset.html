<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Rudiments: semaphoreset Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rudiments
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsemaphoreset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">semaphoreset Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e3615586518f7bec03e88d19c5ae50a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a6e3615586518f7bec03e88d19c5ae50a">semaphoreset</a> ()</td></tr>
<tr class="separator:a6e3615586518f7bec03e88d19c5ae50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebbf8aac64a348bc78729626dc6ac00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#abebbf8aac64a348bc78729626dc6ac00">~semaphoreset</a> ()</td></tr>
<tr class="separator:abebbf8aac64a348bc78729626dc6ac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e8dd3461f436570a621f6ace4f3536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#ac2e8dd3461f436570a621f6ace4f3536">supportsTimedSemaphoreOperations</a> ()</td></tr>
<tr class="separator:ac2e8dd3461f436570a621f6ace4f3536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfc583fff6340ab3b5697fa69c04ac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a1dfc583fff6340ab3b5697fa69c04ac6">supportsUndoSemaphoreOperations</a> ()</td></tr>
<tr class="separator:a1dfc583fff6340ab3b5697fa69c04ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2053d324d1e12251cd1b5d498df83be3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a2053d324d1e12251cd1b5d498df83be3">create</a> (key_t key, mode_t <a class="el" href="classpermissions.html">permissions</a>, int32_t semcount, const int32_t *values)</td></tr>
<tr class="separator:a2053d324d1e12251cd1b5d498df83be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8849740afe623fbb56644e0cd15ea36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#aa8849740afe623fbb56644e0cd15ea36">attach</a> (key_t key, int32_t semcount)</td></tr>
<tr class="separator:aa8849740afe623fbb56644e0cd15ea36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cab64f62c305edad6059010b8c31a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a12cab64f62c305edad6059010b8c31a1">createOrAttach</a> (key_t key, mode_t <a class="el" href="classpermissions.html">permissions</a>, int32_t semcount, const int32_t *values)</td></tr>
<tr class="separator:a12cab64f62c305edad6059010b8c31a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301e37b063c6c2a7fdeda321c16d08d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a301e37b063c6c2a7fdeda321c16d08d6">dontRemove</a> ()</td></tr>
<tr class="separator:a301e37b063c6c2a7fdeda321c16d08d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43619f570d840022bd086d8e9b42ec61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a43619f570d840022bd086d8e9b42ec61">forceRemove</a> ()</td></tr>
<tr class="separator:a43619f570d840022bd086d8e9b42ec61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac9d6363314d18c1ab021f2f6d14ae0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a9ac9d6363314d18c1ab021f2f6d14ae0">getId</a> () const </td></tr>
<tr class="separator:a9ac9d6363314d18c1ab021f2f6d14ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900741be2c25df7a50bfee9267b67a8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a900741be2c25df7a50bfee9267b67a8a">wait</a> (int32_t index)</td></tr>
<tr class="separator:a900741be2c25df7a50bfee9267b67a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0576d7c7c0dc685b476a47ee6a0cf76f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a0576d7c7c0dc685b476a47ee6a0cf76f">wait</a> (int32_t index, int32_t seconds, int32_t nanoseconds)</td></tr>
<tr class="separator:a0576d7c7c0dc685b476a47ee6a0cf76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd002e9fb5dce1c80e0277d2ca2125c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#aefd002e9fb5dce1c80e0277d2ca2125c">signal</a> (int32_t index)</td></tr>
<tr class="separator:aefd002e9fb5dce1c80e0277d2ca2125c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33d0b557a46718024d77e2db6832e4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#ad33d0b557a46718024d77e2db6832e4a">waitWithUndo</a> (int32_t index)</td></tr>
<tr class="separator:ad33d0b557a46718024d77e2db6832e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad947f97fe6e8aac523b972ee0c7c2d0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#ad947f97fe6e8aac523b972ee0c7c2d0b">waitWithUndo</a> (int32_t index, int32_t seconds, int32_t nanoseconds)</td></tr>
<tr class="separator:ad947f97fe6e8aac523b972ee0c7c2d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661084bde30b34f362c4f7ae2a6f6714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a661084bde30b34f362c4f7ae2a6f6714">signalWithUndo</a> (int32_t index)</td></tr>
<tr class="separator:a661084bde30b34f362c4f7ae2a6f6714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c5ccc45eb19294021e96a128fa8812"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#aa1c5ccc45eb19294021e96a128fa8812">setValue</a> (int32_t index, int32_t value)</td></tr>
<tr class="separator:aa1c5ccc45eb19294021e96a128fa8812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc32d8e7b9c704eaab997cbe1e8d2305"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#afc32d8e7b9c704eaab997cbe1e8d2305">getValue</a> (int32_t index)</td></tr>
<tr class="separator:afc32d8e7b9c704eaab997cbe1e8d2305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7309b6a43b96bd9f3d80f2c2ae9304c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a7309b6a43b96bd9f3d80f2c2ae9304c7">setUserName</a> (const char *username)</td></tr>
<tr class="separator:a7309b6a43b96bd9f3d80f2c2ae9304c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95134a9eedff381bde6f06f579d607a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a95134a9eedff381bde6f06f579d607a2">setGroupName</a> (const char *groupname)</td></tr>
<tr class="separator:a95134a9eedff381bde6f06f579d607a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626a7b2d90de566533930929e0399f06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a626a7b2d90de566533930929e0399f06">setUserId</a> (uid_t uid)</td></tr>
<tr class="separator:a626a7b2d90de566533930929e0399f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d11d47daead371843a8e75b85df1dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a91d11d47daead371843a8e75b85df1dc">setGroupId</a> (gid_t gid)</td></tr>
<tr class="separator:a91d11d47daead371843a8e75b85df1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331a23bd4d7cf647bdb72a532bcabd6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a331a23bd4d7cf647bdb72a532bcabd6e">setPermissions</a> (mode_t <a class="el" href="classpermissions.html">permissions</a>)</td></tr>
<tr class="separator:a331a23bd4d7cf647bdb72a532bcabd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d7f2142a3720f9863308d5db639ed0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#af9d7f2142a3720f9863308d5db639ed0">getUserName</a> ()</td></tr>
<tr class="separator:af9d7f2142a3720f9863308d5db639ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e989b1be78c02974c8fbccf1ff6cbd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#af0e989b1be78c02974c8fbccf1ff6cbd">getGroupName</a> ()</td></tr>
<tr class="separator:af0e989b1be78c02974c8fbccf1ff6cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75231472885860c56a183c66f534a627"><td class="memItemLeft" align="right" valign="top">uid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a75231472885860c56a183c66f534a627">getUserId</a> ()</td></tr>
<tr class="separator:a75231472885860c56a183c66f534a627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5146404ff705fc972f59e892a258b27b"><td class="memItemLeft" align="right" valign="top">gid_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a5146404ff705fc972f59e892a258b27b">getGroupId</a> ()</td></tr>
<tr class="separator:a5146404ff705fc972f59e892a258b27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293355c60af02320a432c94ab23f0184"><td class="memItemLeft" align="right" valign="top">mode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a293355c60af02320a432c94ab23f0184">getPermissions</a> ()</td></tr>
<tr class="separator:a293355c60af02320a432c94ab23f0184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf91cdd7584340923f51e09c71016799"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#aaf91cdd7584340923f51e09c71016799">getWaitingForZero</a> (int32_t index)</td></tr>
<tr class="separator:aaf91cdd7584340923f51e09c71016799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa927dbb91461efa68831b4e73fc747d5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#aa927dbb91461efa68831b4e73fc747d5">getWaitingForIncrement</a> (int32_t index)</td></tr>
<tr class="separator:aa927dbb91461efa68831b4e73fc747d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529a17f290efcd57d629086ffc9c4db7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#a529a17f290efcd57d629086ffc9c4db7">retryInterruptedOperations</a> ()</td></tr>
<tr class="separator:a529a17f290efcd57d629086ffc9c4db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa285359617329d495f24cc03291a1cd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsemaphoreset.html#aa285359617329d495f24cc03291a1cd8">dontRetryInterruptedOperations</a> ()</td></tr>
<tr class="separator:aa285359617329d495f24cc03291a1cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Semaphores allow processes to synchronize their activities.</p>
<p>A semaphore is just a number with two primary operations that can be performed on it: <a class="el" href="classsemaphoreset.html#aefd002e9fb5dce1c80e0277d2ca2125c">signal()</a> and <a class="el" href="classsemaphoreset.html#a900741be2c25df7a50bfee9267b67a8a">wait()</a></p>
<p>The operations are analagous to:</p>
<p>int32_t semaphore;</p>
<p>void <a class="el" href="classsemaphoreset.html#aefd002e9fb5dce1c80e0277d2ca2125c">signal()</a> { semaphore++; // increment the semaphore }</p>
<p>void <a class="el" href="classsemaphoreset.html#a900741be2c25df7a50bfee9267b67a8a">wait()</a> { while (semaphore&lt;=0); // wait until the semaphore&gt;0 semaphore&ndash;; // decrement the semaphore }</p>
<p>The actual <a class="el" href="classsemaphoreset.html#aefd002e9fb5dce1c80e0277d2ca2125c">signal()</a> and <a class="el" href="classsemaphoreset.html#a900741be2c25df7a50bfee9267b67a8a">wait()</a> operations are atomic. There is no chance of another process getting context-switched in and changing the semaphore value between the two lines of code in the <a class="el" href="classsemaphoreset.html#a900741be2c25df7a50bfee9267b67a8a">wait()</a> process.</p>
<p>Semaphores can be initialized to any number.</p>
<p>The initial value of the semaphore corresponds to the number of processes that will pass directly through their <a class="el" href="classsemaphoreset.html#a900741be2c25df7a50bfee9267b67a8a">wait()</a> calls without being blocked.</p>
<p>Processes that get blocked calling <a class="el" href="classsemaphoreset.html#a900741be2c25df7a50bfee9267b67a8a">wait()</a> are placed in a queue. When another process calls <a class="el" href="classsemaphoreset.html#aefd002e9fb5dce1c80e0277d2ca2125c">signal()</a>, the process at the head of the queue is unblocked.</p>
<p>A semaphoreset is just a collection of related semaphores.</p>
<p>A semaphoreset is owned by a user and group and has access permissions just like a file. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6e3615586518f7bec03e88d19c5ae50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">semaphoreset::semaphoreset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an instance of the semaphoreset class. </p>

</div>
</div>
<a class="anchor" id="abebbf8aac64a348bc78729626dc6ac00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">semaphoreset::~semaphoreset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes this instance of the semaphoreset class. Removes the semaphoreset if it was created by this class. If it was only attached to, it is not removed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa8849740afe623fbb56644e0cd15ea36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::attach </td>
          <td>(</td>
          <td class="paramtype">key_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>semcount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attaches to an already existing semaphore set identified by "key", containing "semcount" semaphores. </p>

</div>
</div>
<a class="anchor" id="a2053d324d1e12251cd1b5d498df83be3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::create </td>
          <td>(</td>
          <td class="paramtype">key_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>semcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a semaphore set identified by "key" containing "semcount" semaphores. "key" should be generated using the ftok function. "permissions" sets the access permissions for the set. "values" should be an array of starting values for each of the semaphores in the set. </p>

</div>
</div>
<a class="anchor" id="a12cab64f62c305edad6059010b8c31a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::createOrAttach </td>
          <td>(</td>
          <td class="paramtype">key_t&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>semcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to create the semaphore set identified by "key". If this fails, it attempts to attach to a semaphore set identified by "key". </p>

</div>
</div>
<a class="anchor" id="a301e37b063c6c2a7fdeda321c16d08d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void semaphoreset::dontRemove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the destructor not to remove the semaphore set if it was created during a call to <a class="el" href="classsemaphoreset.html#a2053d324d1e12251cd1b5d498df83be3">create()</a> or <a class="el" href="classsemaphoreset.html#a12cab64f62c305edad6059010b8c31a1">createOrAttach()</a>. This is useful if an application creates a semaphore set then forks and wants to delete the semaphore set in the forked process but does not want the semaphore removed from the system. </p>

</div>
</div>
<a class="anchor" id="aa285359617329d495f24cc03291a1cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void semaphoreset::dontRetryInterruptedOperations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes operations not to automatically be retired if interrupted by a signal. The default is to retry automatically. </p>

</div>
</div>
<a class="anchor" id="a43619f570d840022bd086d8e9b42ec61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::forceRemove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the destructor to remove the semaphore set, whether it was created or attached to. </p>

</div>
</div>
<a class="anchor" id="a5146404ff705fc972f59e892a258b27b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gid_t semaphoreset::getGroupId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the group id of the group that owns this semaphore set. </p>

</div>
</div>
<a class="anchor" id="af0e989b1be78c02974c8fbccf1ff6cbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* semaphoreset::getGroupName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of the group that owns this semaphore set</p>
<p>Note that this method allocates a buffer internally and returns it. The calling program must deallocate this buffer.</p>
<p>Note that <a class="el" href="classsemaphoreset.html#af0e989b1be78c02974c8fbccf1ff6cbd">getGroupName()</a> uses the groupentry class. If you are using this method in a multithreaded application, you may need to supply the groupentry class a mutex. See groupentry.h for more detail. </p>

</div>
</div>
<a class="anchor" id="a9ac9d6363314d18c1ab021f2f6d14ae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t semaphoreset::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the internal id for the semaphore set. </p>

</div>
</div>
<a class="anchor" id="a293355c60af02320a432c94ab23f0184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mode_t semaphoreset::getPermissions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the access permissions for this semaphore set. </p>

</div>
</div>
<a class="anchor" id="a75231472885860c56a183c66f534a627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uid_t semaphoreset::getUserId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the user id of the user that owns this semaphore set. </p>

</div>
</div>
<a class="anchor" id="af9d7f2142a3720f9863308d5db639ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* semaphoreset::getUserName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of the user that owns this semaphore set.</p>
<p>Note that this method allocates a buffer internally and returns it. The calling program must deallocate this buffer.</p>
<p>Note that <a class="el" href="classsemaphoreset.html#af9d7f2142a3720f9863308d5db639ed0">getUserName()</a> uses the userentry class. If you are using this method in a multithreaded application, you may need to supply the userentry class a mutex. See userentry.h for more detail. </p>

</div>
</div>
<a class="anchor" id="afc32d8e7b9c704eaab997cbe1e8d2305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t semaphoreset::getValue </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the "index"'th semaphore in the set. </p>

</div>
</div>
<a class="anchor" id="aa927dbb91461efa68831b4e73fc747d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t semaphoreset::getWaitingForIncrement </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of processes that are waiting for the semaphore to increment. </p>

</div>
</div>
<a class="anchor" id="aaf91cdd7584340923f51e09c71016799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t semaphoreset::getWaitingForZero </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of processes that are waiting for the semaphore to become 0. </p>

</div>
</div>
<a class="anchor" id="a529a17f290efcd57d629086ffc9c4db7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void semaphoreset::retryInterruptedOperations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes operations to automatically be retired if interrupted by a signal. This is the default behiavior. </p>

</div>
</div>
<a class="anchor" id="a91d11d47daead371843a8e75b85df1dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::setGroupId </td>
          <td>(</td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>gid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes this semaphore set owned by the group identified by "gid". </p>

</div>
</div>
<a class="anchor" id="a95134a9eedff381bde6f06f579d607a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::setGroupName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>groupname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes this semaphore set owned by the group "groupname".</p>
<p>Note that <a class="el" href="classsemaphoreset.html#a95134a9eedff381bde6f06f579d607a2">setGroupName()</a> uses the groupentry class. If you are using this method in a multithreaded application, you may need to supply the groupentry class a mutex. See groupentry.h for more detail. </p>

</div>
</div>
<a class="anchor" id="a331a23bd4d7cf647bdb72a532bcabd6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::setPermissions </td>
          <td>(</td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the access permissions for this semaphore set to "permissions". </p>

</div>
</div>
<a class="anchor" id="a626a7b2d90de566533930929e0399f06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::setUserId </td>
          <td>(</td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes this semaphore set owned by the user identified by "uid". </p>

</div>
</div>
<a class="anchor" id="a7309b6a43b96bd9f3d80f2c2ae9304c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::setUserName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>username</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes this semaphore set owned by the user "username".</p>
<p>Note that <a class="el" href="classsemaphoreset.html#a7309b6a43b96bd9f3d80f2c2ae9304c7">setUserName()</a> uses the userentry class. If you are using this method in a multithreaded application, you may need to supply the userentry class a mutex. See userentry.h for more detail. </p>

</div>
</div>
<a class="anchor" id="aa1c5ccc45eb19294021e96a128fa8812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::setValue </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the "index"'th semaphore in the set to "value". </p>

</div>
</div>
<a class="anchor" id="aefd002e9fb5dce1c80e0277d2ca2125c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::signal </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signal on the "index"'th semaphore in the set. </p>

</div>
</div>
<a class="anchor" id="a661084bde30b34f362c4f7ae2a6f6714"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::signalWithUndo </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signal on the "index"'th semaphore in the set and undo the signal when the program exits. </p>

</div>
</div>
<a class="anchor" id="ac2e8dd3461f436570a621f6ace4f3536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::supportsTimedSemaphoreOperations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the system supports timed semaphore operations or false otherwise. </p>

</div>
</div>
<a class="anchor" id="a1dfc583fff6340ab3b5697fa69c04ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::supportsUndoSemaphoreOperations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the system supports the variants of the semaphore operations below with Undo in the method names or false otherwise. On platforms that don't support Undo, the methods below just pass through to non-Undo variants. </p>

</div>
</div>
<a class="anchor" id="a900741be2c25df7a50bfee9267b67a8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::wait </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait on the "index"'th semaphore in the set. </p>

</div>
</div>
<a class="anchor" id="a0576d7c7c0dc685b476a47ee6a0cf76f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::wait </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nanoseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait on the "index"'th semaphore in the set until "seconds" and "nanoseconds" elapse. If both "seconds" and "nanoseconds" are 0 then the wait falls through immediately unless the semaphore had already been signaled. If either "seconds" or "nanoseconds" are negative then the timeout is ignored. Returns false and sets errno to EAGAIN if a timeout occurs. Returns false if the system doesn't support timed semaphore operations. </p>

</div>
</div>
<a class="anchor" id="ad33d0b557a46718024d77e2db6832e4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::waitWithUndo </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait on the "index"'th semaphore in the set and undo the wait when the program exits. </p>

</div>
</div>
<a class="anchor" id="ad947f97fe6e8aac523b972ee0c7c2d0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> semaphoreset::waitWithUndo </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nanoseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait on the "index"'th semaphore in the set until "seconds" and "nanoseconds" elapse. If both "seconds" and "nanoseconds" are 0 then the wait falls through immediately unless the semaphore had already been signaled. If either "seconds" or "nanoseconds" are negative then the timeout is ignored. Undo the wait when the program exits. Returns false and sets errno to EAGAIN if a timeout occurs. Returns false if the system doesn't support timed semaphore operations. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 26 2016 17:22:17 for Rudiments by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
