<html>
<head>
<title>firstworks   Programming with Rudiments using the Base Classes</title>
<link href="../css/styles.css" rel="stylesheet">
</head>
<body>

<span class="heading">Programming with Rudiments using the Base Classes</span><br><br>

<ul>
<li><a href="#daemon">Using the daemonprocess Class</a></li>
<li><a href="#inetserversocket">Using the inetserversocket Class</a></li>
<li><a href="#inetclientsocket">Using the inetclientsocket Class</a></li>
<li><a href="#unixserversocket">Using the unixserversocket Class</a></li>
<li><a href="#unixclientsocket">Using the unixclientsocket Class</a></li>
<li><a href="#modemserver">Using the modemserver Class</a></li>
<li><a href="#modemclient">Using the modemclient Class</a></li>
<li><a href="#complex">Using the Complex Initialization Methods of the Server Classes</a></li>
<li><a href="#clientserverfactory">Using the clientserverfactory Class</a></li>
<li><a href="#listener">Using the listener Class</a></li>
</ul>

<a name="daemon"></a>
<span class="heading">Using the daemonprocess Class</span><br><br>

<p>Here is some sample code for a daemon process that writes "hello" every 2 seconds.  Most daemons don't write anything to the console, but this one does for purposes of demonstration.</p>

@daemonprocess.cpp.html@

<a name="inetserversocket"></a>
<span class="heading">Using the inetserversocket Class</span><br><br>

<p>Daemons are commonly used to serve data to clients over a network.  This can be done using the inetserversocket class.  The example below listens on an inet socket for a client connection, receives a string from the client and writes the same string back to the client.</p>

@inetserversocket.cpp.html@

<a name="inetclientsocket"></a>
<span class="heading">Using the inetclientsocket Class</span><br><br>

<p>Here's the code for a client that can talk to the server above.  This client sends a string to the server, reads what the server sends back and prints it out.</p>

@inetclientsocket.cpp.html@

<p>Notice that this server listens on both inet and unix ports.  Inet ports allow clients and servers to talk across a network.  Unix ports allow clients and servers on the same machine to talk through a pipe.  Though clients and servers on the same machine could talk over inet ports, unix ports are much faster and use fewer system resources.</p>

<a name="unixserversocket"></a>
<span class="heading">Using the unixserversocket Class</span><br><br>

<p>Daemons are commonly used to serve data to clients over a network but they can also be used to serve data to processes running on the local machine.  This can be done using the inetserversocket class but if your platform supports unix sockets, then it can be done much faster and more efficiently using the unixserversocket class.  The example below listens on an unix socket for a client connection, receives a string from the client and writes the same string back to the client.</p>

@unixserversocket.cpp.html@

<a name="unixclientsocket"></a>
<span class="heading">Using the unixclientsocket Class</span><br><br>

<p>Here's the code for a client that can talk to the server above.  This client sends a string to the server, reads what the server sends back and prints it out.</p>

@unixclientsocket.cpp.html@

<a name="modemserver"></a>
<span class="heading">Using the modemserver Class</span><br><br>

<p>Even in this day and age, it isn't uncommon for embedded systems to communicate with the outside world over dial-up lines.  To fill this need, rudiments provides implementations of the client and server abstractions for modems as well.  The code below listens for a client connection over a dial-up line.</p>

@modemserver.cpp.html@

<a name="modemclient"></a>
<span class="heading">Using the modemclient Class</span><br><br>

<p>Here's the code for a client that can talk to the modem server above.  This client sends a string to the server, reads what the server sends back and prints it out.</p>

@modemclient.cpp.html@

<a name="complex"></a>
<span class="heading">Using the Complex Initialization methods of the Server Classes</span><br><br>

<p>Setting up a server to listen on a socket is actually a multi-step process.  The listen() methods simplify this process but some applications may require a more flexible interface.  If you need to set socket options or perform additional actions between the steps of socket initialization, you can use the Complex Inititalization methods of the server classes.</p>

<p>Below is an alternative implementation of the inet server in which some socket options are set.</p>

@complexinetserversocket.cpp.html@

<a name="clientserverfactory"></a>
<span class="heading">Using the clientserverfactory Class</span><br><br>

<p>Sometimes you know that you need a client or server at compile time, but won't know until runtime what kind of client or server that you need.  The clientserverfactory class can help in this regard.</p>

@clientserverfactory.cpp.html@

<a name="listener">
<span class="heading">Using the listener Class</span><br><br>

<p>Servers commonly need to listen on multiple sockets for client connections.  They can listen on multiple inet sockets, multiple unix sockets, or a combination.  Technically, they could listen on any set of file descriptors, whether they are all sockets or not.  The listener class can be used to make this possible.</p>

@listener.cpp.html@

</body>
</html>
