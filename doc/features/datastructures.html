<html>

<head>
<title>firstworks Rudiments - Data Structures</title>
<link rel="stylesheet" href="../css/styles.css">
</head>

<body>

<span class="header">Data Structures</span>

<p>For platforms where STL is unavailable or undesirable, Rudiments provides a set of commonly used data structures.</p>

<ul>

<li class="listheader">String Storage</li>
<ul>
<li><a href="../programming/stringbuffer.html">Using the stringbuffer class</a></li>
</ul>

<li class="listheader">Binary Data Storage</li>
<ul>
<li><a href="../programming/bytebuffer.html">Using the bytebuffer class</a></li>
<li><a href="../programming/memorypool.html">Using the memorypool class</a></li>
</ul>

<li class="listheader">Containers</li>
<ul>
<li><a href="../programming/dynamicarray.html">Using the dynamicarray class</a></li>
<li><a href="../programming/staticcarray.html">Using the staticcarray class</a></li>
<li><a href="../programming/linkedlist.html">Using the linkedlist class</a></li>
<li><a href="../programming/singlylinkedlist.html">Using the singlylinkedlist class</a></li>
<li><a href="../programming/dictionary.html">Using the dictionary class</a></li>
</ul>

</ul>

<p>The Rudiments data structures arguably have some advantages over their STL counterparts too.</p>

<ul>
<li>Assignments to staticarray and dynamicarray are more intuitive than std::array and std::vector assignments.</li>
<li>Unlike std::forward_list, the singlylinkedlist class doesn't require C++11.</li>
<li>bytebuffer is far less clumsy than using std::string or std::vector<unsigned char> to store binary data.</li>
<li>The dictionary class uses keys and values directly rather than requiring the std::pair intermediary.</li>
</ul>

</body>
</html>
